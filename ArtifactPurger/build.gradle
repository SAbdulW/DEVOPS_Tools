import groovy.json.JsonSlurper

ext.supportedGradleVersion = '2.3'

allprojects {
    apply plugin: 'idea'
    group = 'com.verint.artifactorypurging'
    version = currentVersion
}

task purgeTask() <<{
    String conf = new File('./conf.json').text
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet("viewOnly: ${viewOnly}")
    logger.quiet("configuration:\r\n${conf}")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    /*
    def obj = new JsonSlurper().parseText(conf)
    List repoConfList = obj.conf
    repoConfList.each { repoConf ->
        logger.quiet("\r\nSTART PROCESSING -> repo: ${repoConf.repoName} - days to keep: ${repoConf.daysToKeep} - minimum to keep: ${repoConf.minimumToKeep} - path match: ${repoConf.pathMatch} - path exclude: ${repoConf.pathExclude}")
        if(repoConf.versionRanges != null){
            repoConf.versionRanges.each{ range ->
                logger.quiet("start: ${range.start} - end: ${range.end}")
            }
        }
        else{
            logger.quiet("This repo does not have version range")
        }
    }
    */

    purge(conf)
}

def purge (String conf){
    def obj = new JsonSlurper().parseText(conf)
    List repoConfList = obj.conf

    repoConfList.each{repoConf ->
        logger.quiet("\r\nSTART PROCESSING -> repo: ${repoConf.repoName} - days to keep: ${repoConf.daysToKeep} - minimum to keep: ${repoConf.minimumToKeep} - path match: ${repoConf.pathMatch} - path exclude: ${repoConf.pathExclude}")

        String repoKey = repoConf.repoName
        int dayToKeep = repoConf.daysToKeep
        int minimumToKeep = repoConf.minimumToKeep
        String pathMatch = repoConf.pathMatch
        String pathExclude = repoConf.pathExclude

        File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
        File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
        File fTop = new File ("$projectDir/${repoKey}_TopList.log")
        File fDoNotPurge = new File ("$projectDir/${repoKey}_DoNotPurgeList.log")
        fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
        fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
        fDoNotPurge.setText("THESE ARTIFACTS HAVE 'DO NOT PURGE' PROPERTY SET AND HAVE NOT BEEN PURGED\r\n")
        if ("${viewOnly}".toBoolean()) {
            fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
        }
        else{
            fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
        }

        // get list of top latest versions of an artifact to keep
        List topLatestPathList = []
        if(repoConf.versionRanges != null){
            repoConf.versionRanges.each{ range ->
                logger.quiet("start: ${range.start} - end: ${range.end}")
                List topLatestPathInRangeList = getXNumberLatestArtifactsPerVersionRange(minimumToKeep, repoKey, range.start, range.end)
                topLatestPathInRangeList.each{ itemPath ->
                    topLatestPathList.add(itemPath)
                    fTop << itemPath + "\r\n"
                }
            }
        }
        else{
            logger.quiet("This repo does not have version range")
            topLatestPathList = getXNumberLatestArtifactsPerVersion(minimumToKeep, repoKey)
            topLatestPathList.each{ itemPath ->
                fTop << itemPath + "\r\n"
            }
        }

        // get list of all artifacts marked as do not purge
        List doNotPurgeList = getArtifactsTaggedAsDoNotPurge(repoKey)
        List doNotPurgePathList = []
        doNotPurgeList.each { item ->
            doNotPurgePathList.add(item.path)
            fDoNotPurge << item.path + "\r\n"
        }

        // get all artifacts OLDER than configured days
        List candidateList = getArtifactsOlderThanXDays (repoKey, pathMatch, dayToKeep)
        candidateList.each { item ->
            fFullL << item.path + "\r\n"

            // check if it should really be purged
            logger.quiet("Checking artifact before purge: $item.path")
            if(doNotPurgePathList.any{it == item.path}){
                logger.quiet("    > It is in DO NOT PURGE list - let it go")
            }
            else if (topLatestPathList.any{it == item.path}){
                logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
            }
            else if (isMatchPurgingExcluded(pathExclude, item.path)){
                logger.quiet("    > It is in EXCLUDED PATH list - let it go")
            }
            else if ("${viewOnly}".toBoolean()) {
                logger.quiet("    > DRY-RUN DELETING: $item.path")
                fDelete << item.path + "\r\n"
            }
            else{
                logger.quiet("    > DELETING: $item.path")
                deleteAnArtifactVersion(item, repoKey, fDelete)
            }
        }

        logger.quiet("DONE PROCESSING -> repo: ${repoConf.repoName}\r\n")
    }
}

task purgeDockerTask() <<{
    String conf = new File('./confDocker.json').text
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet("viewOnly: ${viewOnly}")
    logger.quiet("configuration:\r\n${conf}")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    purgeDocker(conf)
}

def purgeDocker (String conf){
    def obj = new JsonSlurper().parseText(conf)
    List repoConfList = obj.conf

    repoConfList.each{repoConf ->
        logger.quiet("\r\nSTART PROCESSING -> repo: ${repoConf.repoName} - days to keep: ${repoConf.daysToKeep} - minimum to keep: ${repoConf.minimumToKeep} - path match: ${repoConf.pathMatch} - path exclude: ${repoConf.pathExclude}")

        String repoKey = repoConf.repoName
        int dayToKeep = repoConf.daysToKeep
        int minimumToKeep = repoConf.minimumToKeep
        String pathMatch = repoConf.pathMatch
        String pathExclude = repoConf.pathExclude

        File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
        File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
        File fTop = new File ("$projectDir/${repoKey}_TopList.log")
        File fDoNotPurge = new File ("$projectDir/${repoKey}_DoNotPurgeList.log")
        fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
        fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
        fDoNotPurge.setText("THESE ARTIFACTS HAVE 'DO NOT PURGE' PROPERTY SET AND HAVE NOT BEEN PURGED\r\n")
        if ("${viewOnly}".toBoolean()) {
            fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
        }
        else{
            fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
        }

        // get list of top latest versions of an artifact to keep
        List topLatestPathList = []
        logger.quiet("This repo does not have version range")
        topLatestPathList = getXNumberLatestArtifactsPerFlatVersion(minimumToKeep, repoKey)
        topLatestPathList.each{ itemPath ->
            fTop << itemPath + "\r\n"
        }

        // get list of all artifacts marked as do not purge
        List doNotPurgeList = getArtifactsTaggedAsDoNotPurge(repoKey)
        List doNotPurgePathList = []
        doNotPurgeList.each { item ->
            doNotPurgePathList.add(item.path)
            fDoNotPurge << item.path + "\r\n"
        }

        // get all artifacts OLDER than configured days
        List candidateList = getArtifactsOlderThanXDays (repoKey, pathMatch, dayToKeep)
        candidateList.each { item ->
            fFullL << item.path + "\r\n"

            // check if it should really be purged
            logger.quiet("Checking artifact before purge: $item.path")
            if(doNotPurgePathList.any{it == item.path}){
                logger.quiet("    > It is in DO NOT PURGE list - let it go")
            }
            else if (topLatestPathList.any{it == item.path}){
                logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
            }
            else if (isMatchPurgingExcluded(pathExclude, item.path)){
                logger.quiet("    > It is in EXCLUDED PATH list - let it go")
            }
            else if ("${viewOnly}".toBoolean()) {
                logger.quiet("    > DRY-RUN DELETING: $item.path")
                fDelete << item.path + "\r\n"
            }
            else{
                logger.quiet("    > DELETING: $item.path")
                deleteAnArtifactVersion(item, repoKey, fDelete)
            }
        }

        logger.quiet("DONE PROCESSING -> repo: ${repoConf.repoName}\r\n")
    }
}

task purgeNpmTask() <<{
    String conf = new File('./confNpm.json').text
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet("viewOnly: ${viewOnly}")
    logger.quiet("configuration:\r\n${conf}")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    purgeNpm(conf)
}

def purgeNpm (String conf){
    def obj = new JsonSlurper().parseText(conf)
    List repoConfList = obj.conf

    repoConfList.each{repoConf ->
        logger.quiet("\r\n START PROCESSING -> repo: ${repoConf.repoName} - days to keep: ${repoConf.daysToKeep} - minimum to keep: ${repoConf.minimumToKeep} - path match: ${repoConf.pathMatch} - path exclude: ${repoConf.pathExclude}")

        String repoKey = repoConf.repoName
        int dayToKeep = repoConf.daysToKeep
        int minimumToKeep = repoConf.minimumToKeep
        String pathMatch = repoConf.pathMatch
        String pathExclude = repoConf.pathExclude

        File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
        File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
        File fTop = new File ("$projectDir/${repoKey}_TopList.log")
        fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
        fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
        if ("${viewOnly}".toBoolean()) {
            fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
        }
        else{
            fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
        }

        // get list of top latest versions of an artifact to keep
        List topLatestPathList = getXNumberLatestNpmArtifactsPerVersion(5, repoKey)
        topLatestPathList.each{ itemName ->
            fTop << itemName + "\r\n"
        }

        // get all artifacts OLDER than configured days
        List candidateList = getArtifactsOlderThanXDays(repoKey, pathMatch, dayToKeep)
        candidateList.each { item ->
            fFullL << item.path + "/" + item.name + "\r\n"

            // check if it should really be purged
            logger.quiet("Checking artifact before purge: $item.name")
            if (topLatestPathList.any{it == item.name}){
                logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
            }
            else if ("${viewOnly}".toBoolean()) {
                logger.quiet("    > DRY-RUN DELETING: $item.name")
                fDelete << item.name + "\r\n"
            }
            else{
                logger.quiet("    > DELETING: $item.name")
                deleteAnNpmArtifactVersion(item, repoKey, fDelete)
            }
        }

        logger.quiet("DONE PROCESSING -> repo: ${repoConf.repoName}\r\n")
    }
}

task emptyTrashCanTask() <<{
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet(" Trash Can cleanup")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    logger.quiet("START cleaning up Tash Can ...")
    def String result = executeEmptyTrashCan();
    logger.quiet("DONE cleaning up Tash Can. Status: $result")
}

def List getArtifactsOlderThanXDays(String repo, String pathMatch, int x){
    def selectedDate = new Date() - x
    String selectedDateString = selectedDate.format("yyyy-MM-dd hh:mm:ss")
    selectedDateString = selectedDateString.replaceAll(" ","T")
    String notMatch="maven-metadata.xml"

    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"created\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"updated\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"path\":{\"\$match\":\"${pathMatch}*\"}" +
                    "        ,\"path\":{\"\$nmatch\":\".index\"}" +
                    "        ,\"path\":{\"\$nmatch\":\".npm/*\"}" +
                    "        ,\"name\":{\"\$nmatch\":\"${notMatch}*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\",\"size\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getArtifactsTaggedAsDoNotPurge(String repo){
    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"@DONOTPURGE\":{\"\$match\":\"*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getXNumberLatestNpmArtifactsPerVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        String itemName = resultItem."name";
        mapAllItems= putToTheMapNpm(mapAllItems, itemPath, itemName, repoKey)
    }

    // for each item, we need to process the version in format of name-version.build.ext
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPath, listItems ->

        // first, get a distinct list of version of this artifact
        List distinctVersionList = []
        listItems.each{ itemName ->
            // first, parse the version
            int lastIndex1 = itemName.lastIndexOf(".")
            if(lastIndex1 > 0){
                int lastIndex2 = (itemName.substring(0, lastIndex1)).lastIndexOf(".")
                if(lastIndex2 > 0){
                    int lastIndex3 = itemName.lastIndexOf("-")
                    if(lastIndex3 > 0){
                        int lastIndex4 = (itemName.substring(0, lastIndex3)).lastIndexOf("-")
                        if(lastIndex4 > 0){
                            String version = itemName.substring(lastIndex4 + 1, lastIndex2)
                            String buildNumber = itemName.substring(lastIndex2 + 1, lastIndex1)

                            // put this version into the distinct list if it not in there already
                            if(!distinctVersionList.any {it == version}) {
                                distinctVersionList.add(version)
                            }
                        }
                    }
                }
            }

        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        def distinctVersionArtifacts = [:]
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemName ->
                // first, parse the version
                try{
                    int lastIndex1 = itemName.lastIndexOf(".")
                    if(lastIndex1 > 0){
                        int lastIndex2 = (itemName.substring(0, lastIndex1)).lastIndexOf(".")
                        if(lastIndex2 > 0){
                            int lastIndex3 = itemName.lastIndexOf("-")
                            if(lastIndex3 > 0){
                                int lastIndex4 = (itemName.substring(0, lastIndex3)).lastIndexOf("-")
                                if(lastIndex4 > 0){
                                    String version = itemName.substring(lastIndex4 + 1, lastIndex2)
                                    String buildNumber = itemName.substring(lastIndex2 + 1, lastIndex1)

                                    // compare and put in this map if
                                    // make sure the build number is interger otherwise just ignore them - don't keep e.g. SNAPSHOT
                                    if( versionPrefix == version && buildNumber.isInteger()){
                                        artifactList.put(Integer.parseInt(buildNumber), itemName)
                                    }
                                }
                            }
                        }
                    }
                }
                catch(Exception ex){
                    logger.quiet("Got error eith item ${itemName}: ${ex}")
                }                
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }


        logger.quiet("-------------------------------------------\r\n")
        logger.quiet(itemPath + "\r\n")
        distinctVersionList.each{ version ->
            logger.quiet("    " + version + "\r\n")
        }
        logger.quiet("###########################################\r\n")
    }


    return topItemsToKeep

}

def List getXNumberLatestArtifactsPerVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapAllItems= putToTheMap(mapAllItems, itemPath, repoKey)
    }

    // for each item, we need to process the version in format of a.b.c.d
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPathRoot, listItems ->
        List distinctVersionList = []
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

            lastIndex = itemVersion.lastIndexOf(".")
            if(lastIndex > 0){
                String abc = itemVersion.substring(0, lastIndex)

                if(!distinctVersionList.any {it == abc}) {
                    distinctVersionList.add(abc)
                }
            }
        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        def distinctVersionArtifacts = [:]
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemPath ->
                // first, parse the version
                int lastIndex = itemPath.lastIndexOf("/")
                String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

                lastIndex = itemVersion.lastIndexOf(".")
                if(lastIndex > 0){
                    String abc = itemVersion.substring(0, lastIndex)

                    // second, get the build number
                    String d = itemVersion.substring(lastIndex + 1, itemVersion.size())

                    // compare and put in this map if
                    // make sure the build number is interger otherwise just ignore them - don't keep e.g. SNAPSHOT
                    if( versionPrefix == abc && d.isInteger()){
                        artifactList.put(Integer.parseInt(d), itemPath)
                    }
                }
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }
    }

    return topItemsToKeep
}

def List getXNumberLatestArtifactsPerFlatVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapAllItems= putToTheMap(mapAllItems, itemPath, repoKey)
    }

    // for each item, we need to process the version in format of a.b.c.d
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPathRoot, listItems ->
        def artifactList = [:]
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

            if(itemVersion != null && itemVersion.isInteger()){
                artifactList.put(Integer.parseInt(itemVersion), itemPath)
            }
        }

        // now sort it, DESC
        def sortedMap = artifactList.sort { -it.key }

        // and now take the top
        def mapToKeep = sortedMap.take(topElement)

        // last, add all keep items to the final list
        mapToKeep.each{key, value ->
            topItemsToKeep.add(value)
        }

        // for non-numeric flat version, e.g. latest, etc
        // we keep them
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

            if(itemVersion != null && !itemVersion.isInteger()){
                topItemsToKeep.add(itemPath)
            }
        }
    }

    return topItemsToKeep
}

def List getXNumberLatestArtifactsPerVersionRange(int topElement, String repoKey, String start, String end){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapAllItems= putToTheMap(mapAllItems, itemPath, repoKey)
    }

    // for each item, we need to process the version in format of a.b.c.d
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPathRoot, listItems ->
        List distinctVersionList = []
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

            lastIndex = itemVersion.lastIndexOf(".")
            if(lastIndex > 0){
                String abc = itemVersion.substring(0, lastIndex)

                if(!distinctVersionList.any {it == abc}) {
                    distinctVersionList.add(abc)
                }
            }
        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemPath ->
                // first, parse the version
                int lastIndex = itemPath.lastIndexOf("/")
                String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

                lastIndex = itemVersion.lastIndexOf(".")
                if(lastIndex > 0){
                    String abc = itemVersion.substring(0, lastIndex)

                    // second, get the build number
                    String d = itemVersion.substring(lastIndex + 1, itemVersion.size())

                    // compare and put in this map if
                    // make sure the build number is interger otherwise just ignore them - don't keep e.g. SNAPSHOT
                    if( versionPrefix == abc && d.isInteger()){
                        artifactList.put(Integer.parseInt(d), itemPath)
                    }
                }
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }
    }

    // additionally, we need to process version range
    String startRelease = parseVersion2GetRelease(start)
    String startBuildNumber = parseVersion2GetBuildNumber(start)
    String endRelease = parseVersion2GetRelease(end)
    String endBuildNumber = parseVersion2GetBuildNumber(end)
    if (startRelease == endRelease && startBuildNumber.isInteger() && endBuildNumber.isInteger() && startBuildNumber.toInteger() < endBuildNumber.toInteger()){
        mapAllItems.each { itemPathRoot, listItems ->
            // put all items belong to this version range into a map with the key is the build number (for sorting) and value is the item path
            def allItemsInVersionRangeList = [:]
            listItems.each { itemPath ->
                // first, parse the version
                int lastIndex = itemPath.lastIndexOf("/")
                String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

                String abc = parseVersion2GetRelease(itemVersion)
                String d = parseVersion2GetBuildNumber(itemVersion)
                if (abc == startRelease && d.isInteger() && d.toInteger() >= startBuildNumber.toInteger() && d.toInteger() <= endBuildNumber.toInteger()) {
                    allItemsInVersionRangeList.put(d.toInteger(), itemPath)
                }
            }

            // now, sort this list DESC to get the top ones
            def sortedMap = allItemsInVersionRangeList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }

    }

    return topItemsToKeep
}

def List search(String aql ){
    logger.quiet("Artifactory query: $aql")

    def String resultsJsonText = executeAQL(aql)
    def resultsJson = new JsonSlurper().parseText(resultsJsonText)

    List resultsList  = resultsJson.results
    File searchResultFile = new File ("searchResult.json")
    searchResultFile.text = "${resultsJsonText}"

    return resultsList
}

def String executeAQL(String query){
    String filePath =""
    File tempArtifactsList = File.createTempFile("aqlResult",".result");
    filePath = tempArtifactsList.getAbsolutePath()
    filePath = filePath.replaceAll("\\\\","/")

    File aqlQueryFile=File.createTempFile("aqlQueryFile",".query");
    String aqlQueryFilePath = aqlQueryFile.getAbsolutePath()
    aqlQueryFilePath = aqlQueryFilePath.replaceAll("\\\\","/")

    aqlQueryFile.text = "${query}"

    String sCmd = "curl -f -X POST -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"$contextURL/api/search/aql\" -T\"${aqlQueryFilePath}\"  -o \"$filePath\""
    logger.quiet("Execute AQL: ${sCmd}")

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("ArtifactoryPurging: some " + e.toString())

    }

    //def inputJSON = new JsonSlurper().parseText(tempArtifactsList.text)
    String rtnText = tempArtifactsList.text
    tempArtifactsList.delete()
    aqlQueryFile.delete()

    return rtnText
}

def String executeEmptyTrashCan(){
    String filePath =""
    File tempArtifactsList = File.createTempFile("aqlResult",".result");
    filePath = tempArtifactsList.getAbsolutePath()
    filePath = filePath.replaceAll("\\\\","/")

    String sCmd = "curl -f -X POST -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"$contextURL/api/trash/empty\"  -o \"$filePath\""
    logger.quiet("Execute AQL: ${sCmd}")

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("ArtifactoryPurging: some " + e.toString())

    }

    //def inputJSON = new JsonSlurper().parseText(tempArtifactsList.text)
    String rtnText = tempArtifactsList.text
    tempArtifactsList.delete()

    return rtnText
}

def deleteAnNpmArtifactVersion(Object itemToDelete, String repoKey, File fDelete){
    //To delete the whole folder
    String itemFolderToDeleteURI = "${contextURL}" + "/" + repoKey + "/" +  itemToDelete.path + "/" + itemToDelete.name
    itemFolderToDeleteURI = itemFolderToDeleteURI.replaceAll(" ", "%20" )

    String sCmd = "curl -f -X DELETE -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"${itemFolderToDeleteURI}\" "

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }

        logger.quiet("DELETED: ${itemFolderToDeleteURI}")
        fDelete << itemToDelete.name + "\r\n"
    }
    catch (Exception e) {
        logger.quiet("FAILED DELETING: ${itemFolderToDeleteURI}")
        logger.quiet ("    > Reason: " + e.toString())
    }
}

def deleteAnArtifactVersion(Object itemToDelete, String repoKey, File fDelete){
    //To delete the whole folder
    String itemFolderToDeleteURI = "${contextURL}" + "/" + repoKey + "/" +  itemToDelete.path
    itemFolderToDeleteURI = itemFolderToDeleteURI.replaceAll(" ", "%20" )

    String sCmd = "curl -f -X DELETE -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"${itemFolderToDeleteURI}\" "

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }

        logger.quiet("DELETED: ${itemFolderToDeleteURI}")
        fDelete << itemToDelete.path + "\r\n"
    }
    catch (Exception e) {
        logger.quiet("FAILED DELETING: ${itemFolderToDeleteURI}")
        logger.quiet ("    > Reason: " + e.toString())
    }
}

def boolean isMatchPurgingExcluded(String purgingExcluded, String uriToCheck){
    boolean foundIt=false
    if(purgingExcluded == ""){
        return foundIt
    }

    def purgingExcludedList= purgingExcluded.split(',')

    purgingExcludedList.each { purgingExcludedItem ->
        if (!foundIt){
            if (uriToCheck.contains("${purgingExcludedItem}")){
                foundIt = true
            }
        }
    }

    return foundIt
}

def putToTheMap (Object mapLastItems, String itemPath, String repoKey ){
    int lastIndex = itemPath.lastIndexOf("/")
    if(lastIndex <= 0){
        return mapLastItems
    }

    String itemPathRoot = itemPath.substring(0,lastIndex)

    //logger.quiet ("$itemPathRoot:$itemPath")
    List mapLastItem = []
    mapLastItem = mapLastItems.get(itemPathRoot);

    if (mapLastItem!=null){
        if (!mapLastItem.any {it == itemPath}) {
            mapLastItem.add(itemPath)
            mapLastItems.put(itemPathRoot, mapLastItem)
        }
    }else{
        List mapLastItemNew =[]
        mapLastItemNew.add(itemPath)
        mapLastItems.put(itemPathRoot,mapLastItemNew)
    }

    return mapLastItems
}

def putToTheMapNpm (Object mapLastItems, String itemPath, String itemName, String repoKey ){
    List mapLastItem = []
    mapLastItem = mapLastItems.get(itemPath);

    if (mapLastItem!=null){
        if (!mapLastItem.any {it == itemName}) {
            mapLastItem.add(itemName)
            mapLastItems.put(itemPath, mapLastItem)
        }
    }else{
        List mapLastItemNew =[]
        mapLastItemNew.add(itemName)
        mapLastItems.put(itemPath,mapLastItemNew)
    }

    return mapLastItems
}

def parseVersion2GetRelease(String version){
    int lastIndex = version.lastIndexOf(".")
    String abc,d
    if(lastIndex > 0){
        abc = version.substring(0, lastIndex)
        d = version.substring(lastIndex + 1, version.size())
    }

    return abc
}

def parseVersion2GetBuildNumber(String version){
    int lastIndex = version.lastIndexOf(".")
    String abc,d
    if(lastIndex > 0){
        abc = version.substring(0, lastIndex)
        d = version.substring(lastIndex + 1, version.size())
    }

    return d
}

task wrapper(type: Wrapper) {
    gradleVersion = supportedGradleVersion
}