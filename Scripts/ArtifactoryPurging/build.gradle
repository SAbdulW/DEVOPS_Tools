import groovy.json.JsonSlurper

ext.supportedGradleVersion = '2.3'

allprojects {
    apply plugin: 'idea'
    group = 'com.verint.artifactorypurging'
    version = currentVersion
}

task artifactoryPurgingTask() <<{
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet("purgingRepos:             ${purgingRepos}")
    logger.quiet("purgingDateToKeeps:       ${purgingDateToKeeps}")
    logger.quiet("purgingMinimumToKeep:     ${purgingMinimumToKeep}")
    logger.quiet("purgingPathMatch:         ${purgingPathMatch}")
    logger.quiet("viewOnly:                 ${viewOnly}")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    artifactoryPurging ("$purgingRepos", "$purgingDateToKeeps", "$purgingMinimumToKeep", "$purgingPathMatch")
}

task artifactoryPurgingTaskForNpmRepo() <<{
    logger.quiet("ArtifactoryPurging For NPM: ****************************************************************************")
    logger.quiet("purgingNpmRepos:             ${purgingNpmRepos}")
    logger.quiet("purgingNpmDateToKeeps:       ${purgingNpmDateToKeeps}")
    logger.quiet("purgingNpmMinimumToKeep:     ${purgingNpmMinimumToKeep}")
    logger.quiet("purgingNpmPathMatch:         ${purgingNpmPathMatch}")
    logger.quiet("viewOnly:                    ${viewOnly}")
    logger.quiet("ArtifactoryPurging For NPM: ****************************************************************************")

    artifactoryPurgingForNpmRepo ("$purgingNpmRepos", "$purgingNpmDateToKeeps", "$purgingNpmMinimumToKeep", "$purgingNpmPathMatch")
}

def artifactoryPurgingForNpmRepo (String repos, String dayToKeeps, String minimumToKeeps, String pathMatches){
    def reposList = repos.split(',')
    def dayToKeepsList = dayToKeeps.split(',')
    def minimumToKeepsList = minimumToKeeps.split(',')
    def pathMatchesList = pathMatches.split(',')

    if ((reposList.length != dayToKeepsList.length)||(reposList.length !=pathMatchesList.length)){
        logger.quiet ("### ERROR: Wrong configuration, mismatch two lists of repos")
    }
    else{
        for (int i=0; i< reposList.length; i++){
            String repoKey = reposList[i]
            String dayToKeep = dayToKeepsList[i]
            String minimumToKeep = minimumToKeepsList[i]
            String pathMatch = pathMatchesList[i]
            logger.quiet("Processing repo [$repoKey] with [$dayToKeep] days to keep and minimum of [$minimumToKeep] versions of any artifact to keep and only purge partifacts have path match [$pathMatch]\r\n")

            File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
            File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
            File fTop = new File ("$projectDir/${repoKey}_TopList.log")
            fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
            fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
            if ("${viewOnly}".toBoolean()) {
                fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
            }
            else{
                fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
            }

            // get list of top latest versions of an artifact to keep
            List topLatestPathList = getXNumberLatestNpmArtifactsPerVersion(5, repoKey)
            topLatestPathList.each{ itemName ->
                fTop << itemName + "\r\n"
            }

            // get all artifacts OLDER than configured days
            List candidateList = getArtifactsOlderThanXDays (repoKey, pathMatch, dayToKeep.toInteger())
            candidateList.each { item ->
                fFullL << item.path + "/" + item.name + "\r\n"

                // check if it should really be purged
                logger.quiet("Checking artifact before purge: $item.name")
                if (topLatestPathList.any{it == item.name}){
                    logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
                }
                else if ("${viewOnly}".toBoolean()) {
                    logger.quiet("    > DRY-RUN DELETING: $item.name")
                    fDelete << item.name + "\r\n"
                }
                else{
                    logger.quiet("    > DELETING: $item.name")
                    deleteAnNpmArtifactVersion(item, repoKey, fDelete)
                }
            }
        }
    }
}

def artifactoryPurging (String repos, String dayToKeeps, String minimumToKeeps, String pathMatches){
    def reposList = repos.split(',')
    def dayToKeepsList = dayToKeeps.split(',')
    def minimumToKeepsList = minimumToKeeps.split(',')
    def pathMatchesList = pathMatches.split(',')

    if ((reposList.length != dayToKeepsList.length)||(reposList.length !=pathMatchesList.length)){
        logger.quiet ("### ERROR: Wrong configuration, mismatch two lists of repos")
    }
    else{
        for (int i=0; i< reposList.length; i++){
            String repoKey = reposList[i]
            String dayToKeep = dayToKeepsList[i]
            String minimumToKeep = minimumToKeepsList[i]
            String pathMatch = pathMatchesList[i]
            logger.quiet("Processing repo [$repoKey] with [$dayToKeep] days to keep and minimum of [$minimumToKeep] versions of any artifact to keep and only purge partifacts have path match [$pathMatch]\r\n")

            File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
            File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
            File fTop = new File ("$projectDir/${repoKey}_TopList.log")
            File fDoNotPurge = new File ("$projectDir/${repoKey}_DoNotPurgeList.log")
            fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
            fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
            fDoNotPurge.setText("THESE ARTIFACTS HAVE 'DO NOT PURGE' PROPERTY SET AND HAVE NOT BEEN PURGED\r\n")
            if ("${viewOnly}".toBoolean()) {
                fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
            }
            else{
                fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
            }

            // get list of top latest versions of an artifact to keep
            List topLatestPathList = getXNumberLatestArtifactsPerVersion("$minimumToKeep".toInteger(), repoKey)
            topLatestPathList.each{ itemPath ->
                fTop << itemPath + "\r\n"
            }


            // get list of all artifacts marked as do not purge
            List doNotPurgeList = getArtifactsTaggedAsDoNotPurge(repoKey, pathMatch)
            List doNotPurgePathList = []
            doNotPurgeList.each { item ->
                doNotPurgePathList.add(item.path)
                fDoNotPurge << item.path + "\r\n"
            }

            // get all artifacts OLDER than configured days
            List candidateList = getArtifactsOlderThanXDays (repoKey, pathMatch, dayToKeep.toInteger())
            candidateList.each { item ->
                fFullL << item.path + "\r\n"

                // check if it should really be purged
                logger.quiet("Checking artifact before purge: $item.path")
                if(doNotPurgePathList.any{it == item.path}){
                    logger.quiet("    > It is in DO NOT PURGE list - let it go")
                }
                else if (topLatestPathList.any{it == item.path}){
                    logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
                }
                else if (isMatchPurgingExcluded("${purgingExcluded}", item.path)){
                    logger.quiet("    > It is in EXCLUDED PATH list - let it go")
                }
                else if ("${viewOnly}".toBoolean()) {
                    logger.quiet("    > DRY-RUN DELETING: $item.path")
                    fDelete << item.path + "\r\n"
                }
                else{
                    logger.quiet("    > DELETING: $item.path")
                    deleteAnArtifactVersion(item, repoKey, fDelete)
                }
            }


        }
    }
}

def List getArtifactsOlderThanXDays(String repo, String pathMatch, int x){
    def selectedDate = new Date() - x
    String selectedDateString = selectedDate.format("yyyy-MM-dd hh:mm:ss")
    selectedDateString = selectedDateString.replaceAll(" ","T")
    String notMatch="maven-metadata.xml"

    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"created\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"updated\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"path\":{\"\$match\":\"${pathMatch}*\"}" +
                    "        ,\"name\":{\"\$nmatch\":\"${notMatch}*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getArtifactsTaggedAsDoNotPurge(String repo, String pathMatch){
    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"@DONOTPURGE\":{\"\$match\":\"*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getXNumberLatestNpmArtifactsPerVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        String itemName = resultItem."name";
        mapAllItems= putToTheMapNpm(mapAllItems, itemPath, itemName, repoKey)
    }

    // for each item, we need to process the version in format of name-version.build.ext
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPath, listItems ->

        // first, get a distinct list of version of this artifact
        List distinctVersionList = []
        listItems.each{ itemName ->
            // first, parse the version
            int lastIndex1 = itemName.lastIndexOf(".")
            if(lastIndex1 > 0){
                int lastIndex2 = (itemName.substring(0, lastIndex1)).lastIndexOf(".")
                if(lastIndex2 > 0){
                    int lastIndex3 = itemName.lastIndexOf("-")
                    if(lastIndex3 > 0){
                        int lastIndex4 = (itemName.substring(0, lastIndex3)).lastIndexOf("-")
                        if(lastIndex4 > 0){
                            String version = itemName.substring(lastIndex4 + 1, lastIndex2)
                            String buildNumber = itemName.substring(lastIndex2 + 1, lastIndex1)

                            // put this version into the distinct list if it not in there already
                            if(!distinctVersionList.any {it == version}) {
                                distinctVersionList.add(version)
                            }
                        }
                    }
                }
            }

        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        def distinctVersionArtifacts = [:]
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemName ->
                // first, parse the version
                int lastIndex1 = itemName.lastIndexOf(".")
                if(lastIndex1 > 0){
                    int lastIndex2 = (itemName.substring(0, lastIndex1)).lastIndexOf(".")
                    if(lastIndex2 > 0){
                        int lastIndex3 = itemName.lastIndexOf("-")
                        if(lastIndex3 > 0){
                            int lastIndex4 = (itemName.substring(0, lastIndex3)).lastIndexOf("-")
                            if(lastIndex4 > 0){
                                String version = itemName.substring(lastIndex4 + 1, lastIndex2)
                                String buildNumber = itemName.substring(lastIndex2 + 1, lastIndex1)

                                // compare and put in this map if
                                // make sure the build number is interger otherwise just ignore them - don't keep e.g. SNAPSHOT
                                if( versionPrefix == version && buildNumber.isInteger()){
                                    artifactList.put(Integer.parseInt(buildNumber), itemName)
                                }
                            }
                        }
                    }
                }
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }


        logger.quiet("-------------------------------------------\r\n")
        logger.quiet(itemPath + "\r\n")
        distinctVersionList.each{ version ->
            logger.quiet("    " + version + "\r\n")
        }
        logger.quiet("###########################################\r\n")
    }


    return topItemsToKeep

}

def List getXNumberLatestArtifactsPerVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapAllItems= putToTheMap(mapAllItems, itemPath, repoKey)
    }

    // for each item, we need to process the version in format of a.b.c.d
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPathRoot, listItems ->
        List distinctVersionList = []
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

            lastIndex = itemVersion.lastIndexOf(".")
            if(lastIndex > 0){
                String abc = itemVersion.substring(0, lastIndex)

                if(!distinctVersionList.any {it == abc}) {
                    distinctVersionList.add(abc)
                }
            }
        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        def distinctVersionArtifacts = [:]
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemPath ->
                // first, parse the version
                int lastIndex = itemPath.lastIndexOf("/")
                String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())

                lastIndex = itemVersion.lastIndexOf(".")
                if(lastIndex > 0){
                    String abc = itemVersion.substring(0, lastIndex)

                    // second, get the build number
                    String d = itemVersion.substring(lastIndex + 1, itemVersion.size())

                    // compare and put in this map if
                    // make sure the build number is interger otherwise just ignore them - don't keep e.g. SNAPSHOT
                    if( versionPrefix == abc && d.isInteger()){
                        artifactList.put(Integer.parseInt(d), itemPath)
                    }
                }
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }
    }

    return topItemsToKeep
}

def List search(String aql ){
    logger.quiet("Artifactory query: $aql")

    def String resultsJsonText = executeAQL(aql)
    def resultsJson = new JsonSlurper().parseText(resultsJsonText)

    List resultsList  = resultsJson.results
    File searchResultFile = new File ("searchResult.json")
    searchResultFile.text = "${resultsJsonText}"

    return resultsList
}

def String executeAQL(String query){
    String filePath =""
    File tempArtifactsList = File.createTempFile("aqlResult",".result");
    filePath = tempArtifactsList.getAbsolutePath()
    filePath = filePath.replaceAll("\\\\","/")

    File aqlQueryFile=File.createTempFile("aqlQueryFile",".query");
    String aqlQueryFilePath = aqlQueryFile.getAbsolutePath()
    aqlQueryFilePath = aqlQueryFilePath.replaceAll("\\\\","/")

    aqlQueryFile.text = "${query}"

    String sCmd = "curl -f -X POST -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"$contextURL/api/search/aql\" -T\"${aqlQueryFilePath}\"  -o \"$filePath\""
    logger.quiet("Execute AQL: ${sCmd}")

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("ArtifactoryPurging: some " + e.toString())

    }

    //def inputJSON = new JsonSlurper().parseText(tempArtifactsList.text)
    String rtnText = tempArtifactsList.text
    tempArtifactsList.delete()
    aqlQueryFile.delete()

    return rtnText
}

def deleteAnNpmArtifactVersion(Object itemToDelete, String repoKey, File fDelete){
    //To delete the whole folder
    String itemFolderToDeleteURI = "${contextURL}" + "/" + repoKey + "/" +  itemToDelete.path + "/" + itemToDelete.name
    itemFolderToDeleteURI = itemFolderToDeleteURI.replaceAll(" ", "%20" )

    String sCmd = "curl -f -X DELETE -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"${itemFolderToDeleteURI}\" "

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }

        logger.quiet("DELETED: ${itemFolderToDeleteURI}")
        fDelete << itemToDelete.name + "\r\n"
    }
    catch (Exception e) {
        logger.quiet("FAILED DELETING: ${itemFolderToDeleteURI}")
        logger.quiet ("    > Reason: " + e.toString())
    }
}

def deleteAnArtifactVersion(Object itemToDelete, String repoKey, File fDelete){
    //To delete the whole folder
    String itemFolderToDeleteURI = "${contextURL}" + "/" + repoKey + "/" +  itemToDelete.path
    itemFolderToDeleteURI = itemFolderToDeleteURI.replaceAll(" ", "%20" )

    String sCmd = "curl -f -X DELETE -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"${itemFolderToDeleteURI}\" "

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }

        logger.quiet("DELETED: ${itemFolderToDeleteURI}")
        fDelete << itemToDelete.path + "\r\n"
    }
    catch (Exception e) {
        logger.quiet("FAILED DELETING: ${itemFolderToDeleteURI}")
        logger.quiet ("    > Reason: " + e.toString())
    }
}

def boolean isMatchPurgingExcluded(String purgingExcluded, String uriToCheck){
    boolean foundIt=false
    if(purgingExcluded == ""){
        return foundIt
    }

    def purgingExcludedList= purgingExcluded.split(',')

    purgingExcludedList.each { purgingExcludedItem ->
        if (!foundIt){
            if (uriToCheck.contains("${purgingExcludedItem}")){
                foundIt = true
            }
        }
    }

    return foundIt
}

def putToTheMap (Object mapLastItems, String itemPath, String repoKey ){

    int lastIndex = itemPath.lastIndexOf("/")
    String itemPathRoot = itemPath.substring(0,lastIndex)

    if (repoKey=="devops"){
        lastIndex = itemPathRoot.lastIndexOf("/")
        itemPathRoot = itemPathRoot.substring(0,lastIndex)
    }

    //logger.quiet ("$itemPathRoot:$itemPath")
    List mapLastItem = []
    mapLastItem = mapLastItems.get(itemPathRoot);

    if (mapLastItem!=null){
        if (!mapLastItem.any {it == itemPath}) {
            mapLastItem.add(itemPath)
            mapLastItems.put(itemPathRoot, mapLastItem)
        }
    }else{
        List mapLastItemNew =[]
        mapLastItemNew.add(itemPath)
        mapLastItems.put(itemPathRoot,mapLastItemNew)
    }

    return mapLastItems
}

def putToTheMapNpm (Object mapLastItems, String itemPath, String itemName, String repoKey ){
    List mapLastItem = []
    mapLastItem = mapLastItems.get(itemPath);

    if (mapLastItem!=null){
        if (!mapLastItem.any {it == itemName}) {
            mapLastItem.add(itemName)
            mapLastItems.put(itemPath, mapLastItem)
        }
    }else{
        List mapLastItemNew =[]
        mapLastItemNew.add(itemName)
        mapLastItems.put(itemPath,mapLastItemNew)
    }

    return mapLastItems
}

task wrapper(type: Wrapper) {
    gradleVersion = supportedGradleVersion
}