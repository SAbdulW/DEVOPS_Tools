import groovy.json.JsonSlurper

ext.supportedGradleVersion = '2.3'

allprojects {
	apply plugin: 'idea'
	group = 'com.verint.artifactorypurging'
	version = currentVersion
}

task artifactoryPurgingTask() <<{
    logger.quiet("ArtifactoryPurging: ****************************************************************************")
    logger.quiet("purgingRepos:             ${purgingRepos}")
    logger.quiet("purgingDateToKeeps:       ${purgingDateToKeeps}")
    logger.quiet("purgingMinimumToKeep:     ${purgingMinimumToKeep}")
    logger.quiet("purgingPathMatch:         ${purgingPathMatch}")
    logger.quiet("viewOnly:                 ${viewOnly}")
    logger.quiet("ArtifactoryPurging: ****************************************************************************")

    artifactoryPurging ("$purgingRepos", "$purgingDateToKeeps", "$purgingMinimumToKeep", "$purgingPathMatch")
}

def artifactoryPurging (String repos, String dayToKeeps, String minimumToKeeps, String pathMatches){
    def reposList = repos.split(',')
    def dayToKeepsList = dayToKeeps.split(',')
    def minimumToKeepsList = minimumToKeeps.split(',')
    def pathMatchesList = pathMatches.split(',')

    if ((reposList.length != dayToKeepsList.length)||(reposList.length !=pathMatchesList.length)){
        logger.quiet ("### ERROR: Wrong configuration, mismatch two lists of repos")
    }
    else{
        for (int i=0; i< reposList.length; i++){
            String repoKey = reposList[i]
            String dayToKeep = dayToKeepsList[i]
            String minimumToKeep = minimumToKeepsList[i]
            String pathMatch = pathMatchesList[i]
            logger.quiet("Processing repo [$repoKey] with [$dayToKeep] days to keep and minimum of [$minimumToKeep] versions of any artifact to keep and only purge partifacts have path match [$pathMatch]\r\n")

            File fFullL = new File ("$projectDir/${repoKey}_FullList.log")
            File fDelete = new File ("$projectDir/${repoKey}_DeleteList.log")
            File fTop = new File ("$projectDir/${repoKey}_TopList.log")
            File fDoNotPurge = new File ("$projectDir/${repoKey}_DoNotPurgeList.log")
            fFullL.setText("ALL ARTIFACTS OLDER THAN $dayToKeep DAYS\r\n")
            fTop.setText("THESE ARTIFACTS ARE THE TOP LATEST TO KEEP FROM PURGING\r\n")
            fDoNotPurge.setText("THESE ARTIFACTS HAVE 'DO NOT PURGE' PROPERTY SET AND HAVE NOT BEEN PURGED\r\n")
            if ("${viewOnly}".toBoolean()) {
                fDelete.setText("THIS IS JUST A DRY RUN. NO REAL PURGING HAPPENING\r\n")
            }
            else{
                fDelete.setText("THESE ARTIFACTS HAVE BEEN PURGED\r\n")
            }

            // get list of top latest versions of an artifact to keep
            List topLatestPathList = getXNumberLatestArtifactsPerVersion("$minimumToKeep".toInteger(), repoKey)
            topLatestPathList.each{ itemPath ->
                fTop << itemPath + "\r\n"
            }


            // get list of all artifacts marked as do not purge
            List doNotPurgeList = getArtifactsTaggedAsDoNotPurge(repoKey, pathMatch)
            List doNotPurgePathList = []
            doNotPurgeList.each { item ->
                doNotPurgePathList.add(item.path)
                fDoNotPurge << item.path + "\r\n"
            }

            // get all artifacts OLDER than configured days
            List candidateList = getArtifactsOlderThanXDays (repoKey, pathMatch, dayToKeep.toInteger())
            candidateList.each { item ->
                fFullL << item.path + "\r\n"

                // check if it should really be purged
                logger.quiet("Checking artifact before purge: $item.path")
                if(doNotPurgePathList.any{it == item.path}){
                    logger.quiet("    > It is in DO NOT PURGE list - let it go")
                }
                else if (topLatestPathList.any{it == item.path}){
                    logger.quiet("    > It is in TOP MINIMUM TO KEEP list - let it go")
                }
                else if (isMatchPurgingExcluded("${purgingExcluded}", item.path)){
                    logger.quiet("    > It is in EXCLUDED PATH list - let it go")
                }
                else if ("${viewOnly}".toBoolean()) {
                    logger.quiet("    > DRY-RUN DELETING: $item.path")
                    fDelete << item.path + "\r\n"
                }
                else{
                    logger.quiet("    > DELETING: $item.path")
                    deleteAnArtifactVersion(item, repoKey)
                    fDelete << item.path + "\r\n"
                }
            }


        }
    }
}

def List getArtifactsOlderThanXDays(String repo, String pathMatch, int x){
    def selectedDate = new Date() - x
    String selectedDateString = selectedDate.format("yyyy-MM-dd hh:mm:ss")
    selectedDateString = selectedDateString.replaceAll(" ","T")
    String notMatch="maven-metadata.xml"

    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"created\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"updated\":{\"\$lt\":\"${selectedDateString}\"}" +
                    "        ,\"path\":{\"\$match\":\"${pathMatch}*\"}" +
                    "        ,\"name\":{\"\$nmatch\":\"${notMatch}*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getArtifactsTaggedAsDoNotPurge(String repo, String pathMatch){
    String aqlQuery =
            "items.find" +
                    "(" +
                    "    {" +
                    "        \"repo\":{\"\$eq\":\"${repo}\"}" +
                    "        ,\"@DONOTPURGE\":{\"\$match\":\"*\"}" +
                    "    }"  +
                    ").include(\"name\", \"path\")"

    List resultsList  = search(aqlQuery)
    return resultsList
}

def List getXNumberLatestArtifacts(int topElement, String repoKey, File fKeep){
    def mapLastItems = [:]
    def mapLastItemsKeep = [:]

    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapLastItems= putToTheMap(mapLastItems, itemPath, repoKey)
    }

    mapLastItems.each { itemPathRoot, listItems ->
        List listToKeep = listItems.reverse().take(topElement)
        mapLastItemsKeep.put (itemPathRoot,listToKeep )
    }

    def rtnList = []
    mapLastItemsKeep.each {  itemPathRoot, listItems ->
        fKeep << "========================Item: ${itemPathRoot}\n"
        listItems.each { item ->
            fKeep << "${item}\r\n"
            rtnList.add (item)
        }
    }

    return rtnList
}

def List getXNumberLatestArtifactsPerVersion(int topElement, String repoKey){
    def mapAllItems = [:]
    List topItemsToKeep = []

    // get all artifacts from this repo, then put them into a map
    // [rootPath: [version1, version2, ...], rootPath:[version1, version2,...], ...]
    List resultsList = getArtifactsOlderThanXDays(repoKey, "*", 0)
    resultsList.each { resultItem ->
        String itemPath = resultItem."path";
        mapAllItems= putToTheMap(mapAllItems, itemPath, repoKey)
    }

    // for each item, we need to process the version in format of a.b.c.d
    // to take out the top of each distinguished version to keep
    mapAllItems.each { itemPathRoot, listItems ->
        List distinctVersionList = []
        listItems.each{ itemPath ->
            // first, parse the version
            int lastIndex = itemPath.lastIndexOf("/")
            String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())
            String[] versionDigit = itemVersion.tokenize('.')

            // second, build distinct version list
            String abc = versionDigit[0] + "." + versionDigit[1] + "." + versionDigit[2]
            if(!distinctVersionList.any {it == abc}){
                distinctVersionList.add(abc)
            }
        }

        // now we got the list of distinct version list of this root artifact
        // next we need to build an order map of all versions for each distinct version
        def distinctVersionArtifacts = [:]
        distinctVersionList.each{ versionPrefix ->
            def artifactList = [:]
            listItems.each{ itemPath ->
                // first, parse the version
                int lastIndex = itemPath.lastIndexOf("/")
                String itemVersion = itemPath.substring(lastIndex + 1, itemPath.size())
                String[] versionDigit = itemVersion.tokenize('.')

                // second, get the build number
                String abc = versionDigit[0] + "." + versionDigit[1] + "." + versionDigit[2]
                String d = versionDigit[3]

                // compare and put in this map if
                if( versionPrefix == abc){
                    artifactList.put(Integer.parseInt(d), itemPath)
                }
            }

            // now sort it, DESC
            def sortedMap = artifactList.sort { -it.key }

            // and now take the top
            def mapToKeep = sortedMap.take(topElement)

            // last, add all keep items to the final list
            mapToKeep.each{key, value ->
                topItemsToKeep.add(value)
            }
        }
    }

    return topItemsToKeep
}

def List search(String aql ){
    logger.quiet("Artifactory query: $aql")

    def String resultsJsonText = executeAQL(aql)
    def resultsJson = new JsonSlurper().parseText(resultsJsonText)

    List resultsList  = resultsJson.results
    File searchResultFile = new File ("searchResult.json")
    searchResultFile.text = "${resultsJsonText}"

    return resultsList
}

def String executeAQL(String query){
    String filePath =""
    File tempArtifactsList = File.createTempFile("aqlResult",".result");
    filePath = tempArtifactsList.getAbsolutePath()
    filePath = filePath.replaceAll("\\\\","/")

    File aqlQueryFile=File.createTempFile("aqlQueryFile",".query");
    String aqlQueryFilePath = aqlQueryFile.getAbsolutePath()
    aqlQueryFilePath = aqlQueryFilePath.replaceAll("\\\\","/")

    aqlQueryFile.text = "${query}"

    String sCmd = "curl -f -X POST -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"$contextURL/api/search/aql\" -T\"${aqlQueryFilePath}\"  -o \"$filePath\""
    logger.quiet("Execute AQL: ${sCmd}")

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("ArtifactoryPurging: some " + e.toString())

    }

    //def inputJSON = new JsonSlurper().parseText(tempArtifactsList.text)
    String rtnText = tempArtifactsList.text
    tempArtifactsList.delete()
    aqlQueryFile.delete()

    return rtnText
}

def deleteAnArtifactVersion(Object itemToDelete, String repoKey){
    //To delete the whole folder
    String itemFolderToDeleteURI = "${contextURL}" + "/" + repoKey + "/" +  itemToDelete.path
    itemFolderToDeleteURI = itemFolderToDeleteURI.replaceAll(" ", "%20" )

    String sCmd = "curl -f -X DELETE -u \"" + "$uname" + "\":\"" + "$pword" + "\" \"${itemFolderToDeleteURI}\" "

    try {
        exec {
            commandLine 'sh', '-c', sCmd
        }
    }
    catch (Exception e) {
        logger.quiet("FAILED DELETING: ${itemFolderToDeleteURI}")
        logger.quiet ("    > Reason: " + e.toString())
    }
}

def boolean isMatchPurgingExcluded(String purgingExcluded, String uriToCheck){
    def purgingExcludedList= purgingExcluded.split(',')
    boolean foundIt=false
    purgingExcludedList.each { purgingExcludedItem ->
        if (!foundIt){
            if (uriToCheck.contains("${purgingExcludedItem}")){
                foundIt = true
            }
        }
    }

    return foundIt
}

def putToTheMap (Object mapLastItems, String itemPath, String repoKey ){

    int lastIndex = itemPath.lastIndexOf("/")
    String itemPathRoot = itemPath.substring(0,lastIndex)

    if (repoKey=="devops"){
        lastIndex = itemPathRoot.lastIndexOf("/")
        itemPathRoot = itemPathRoot.substring(0,lastIndex)
    }

    //logger.quiet ("$itemPathRoot:$itemPath")
    List mapLastItem = []
    mapLastItem = mapLastItems.get(itemPathRoot);

    if (mapLastItem!=null){
        if (!mapLastItem.any {it == itemPath}) {
            mapLastItem.add(itemPath)
            mapLastItems.put(itemPathRoot, mapLastItem)
        }
    }else{
        List mapLastItemNew =[]
        mapLastItemNew.add(itemPath)
        mapLastItems.put(itemPathRoot,mapLastItemNew)
    }

    return mapLastItems
}

task wrapper(type: Wrapper) {
	gradleVersion = supportedGradleVersion
}