import groovy.json.JsonSlurper

buildscript {
    repositories {
        maven {
            url "${artifactory_contextUrl}/plugins-release"
            credentials {
                username = "${artifactory_user}"
                password = "${artifactory_password}"
            }
        }
    }
    dependencies {
        classpath(group: 'org.jfrog.buildinfo', name: 'build-info-extractor-gradle', version: '2.2.4')
        classpath 'com.verint.plugins:vebutu-plugin:latest.release'
        classpath 'com.github.sarxos:windows-registry-util:latest.release'
        classpath 'org.yaml:snakeyaml:1.16-SNAPSHOT'
    }
}

apply plugin: 'java'
apply plugin: 'vebutu'
apply plugin: 'artifactory'

ext.supportedGradleVersion = '2.3'

allprojects {
    apply plugin: 'idea'
    if (runMode=='dev') {
        group = 'com.verint.puppet.gradle'
        version = currentVersion
    }else{
        group = "com.verint.puppet.logs.${environment}"
        version = currentVersion
    }
}


repositories {
    //Resolving the artifact from the release repo, the one promoted by team
    maven {
        url "${artifactory_contextUrl}/ci-wfo-puppet-repos"
        credentials {
            username = "${artifactory_user}"
            password = "${artifactory_password}"
        }
    }
}

configurations {
    //envConfig
}

dependencies {
    //   envConfig 'com.microsoft.technet.sysinternals:PSTools:2.11@zip'
    // envConfig 'com.poweradmin:paexec:1.26@zip'
}

// prepare environment, getting the tools
task init() << {
    //ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("PSTools-")}, dest: "${projectDir}\\Pstools\\") { patternset { include(name:"PsExec.exe")}}
    //ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("paexec")}, dest: "${projectDir}\\PAExec\\")
}

task getInstalledVersions() << {
    logger.quiet ("GradlePuppetClient: getting the installed versions from the certname ${certname}")
    readRegistries()
    //loadYAML()
}

import com.github.sarxos.winreg.HKey;
import com.github.sarxos.winreg.RegistryException;
import com.github.sarxos.winreg.WindowsRegistry;

// Master task to be called when gradle run
task runGradle()<< {
    tasks.getInstalledVersions.execute()
}

if (runMode=='dev') {
    archivesBaseName = "GradlePuppetClient"
    def zipFile = file("$buildDir/fullsource.zip")
    artifacts {
        archives file: zipFile, name: "${archivesBaseName}", type: 'zip'
    }
}else{ //production
    archivesBaseName = "${certname}"
    def zipFile = file("$buildDir/pplog.zip")
    artifacts {
        archives file: zipFile, name: "${archivesBaseName}", type: 'zip'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = supportedGradleVersion
}

//Artifactory configuration

task zipFullSrc() <<{
    String srcDir = "$projectDir"
    logger.quiet("Zipping the source from: ${srcDir}")

    ant.zip(destfile: "$buildDir/fullsource.zip") {
        fileset(dir: "${srcDir}") {
            //include(name: '**.xml')
            exclude(name: ".gradle\\**\\*")
            exclude(name: "build\\**\\*")
            exclude(name: "**\\*.zip")
        }
    }
}

task zipLogs() <<{
    String srcDir = "$srcLogDir"
    logger.quiet("Zipping the log from: ${srcDir} from puppet client")
    ant.copy (todir:"${srcDir}", file:"${srcLogInstallXML}")
    //Copy the production logs
    copyProductionLogs "${impact360Dir}\\Data","${srcDir}\\productionLogs"

    ant.zip(destfile: "$buildDir/pplog.zip") {
        fileset(dir: "${srcDir}") {
            //include(name: '**.xml')
            exclude(name: ".gradle\\**\\*")
            exclude(name: "build\\**\\*")
            exclude(name: "**\\*.zip")
        }

    }
}

def copyProductionLogs (String srcDir, String dstDir){
    // srcDir: C:\\Impact360\\Data
    ant.copy (todir: "${dstDir}" ){
        fileset(dir: "${srcDir}") {
            include(name: "Logs\\**\\*.log")
        }
    }
}

if (runMode=='dev') {
    artifactoryPublish.dependsOn zipFullSrc
}else{
    artifactoryPublish.dependsOn zipLogs
}

artifactory {
    publish {
        contextUrl = "${artifactory_contextUrl}"	// The base Artifactory URL if not overridden by the publisher/resolver
        repository {
            repoKey = 'devops'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
    }
    resolve {
        contextUrl = "${artifactory_contextUrl}"	// The base Artifactory URL if not overridden by the publisher/resolver
        repository {
            repoKey = 'repo'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
    }
}


// List of function that we can use

def readRegistries( ){
    def parsedXmlObj =loadXML ("${srcLogInstallXML}")
    WindowsRegistry reg = WindowsRegistry.getInstance();
    //String tree = "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
    //String value = reg.readString(HKey.HKLM, tree, "ProductName");
    String branch = "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
    List<String> keys = reg.readStringSubKeys(HKey.HKLM, branch);
    def registryDiffFile = new File ("$srcLogDir\\ServerVersionInstalledMismatch.log")
    registryDiffFile.write "List of mismatch of registry and ServerVersionInformation.xml\n"

    def fullRegistryFile = new File ("$srcLogDir\\registryExport.json")
    String fullRegistryContent = ""
    String jsonItemHeader=""
    for (String key : keys) {
        String valueDisplayName = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayName");
        String valueDisplayVersion = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayVersion");
        String valuePublisher = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "Publisher");

        def component = getXMLComponent(parsedXmlObj,key)

        if (component !=null){
            if ((component.@name != valueDisplayName) || (component.@version != valueDisplayVersion)){
                registryDiffFile << "Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})\n"
                logger.quiet("Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})")
            }
        }else {
            if (valuePublisher!=null && valuePublisher.contains("Impact")){
                registryDiffFile << "**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}\n"
                logger.quiet("**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}")
            }
        }

        if (fullRegistryContent=="") {
            fullRegistryContent ="  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }else{
            fullRegistryContent =fullRegistryContent +",\n  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }


    }

    fullRegistryFile.write "{\n${fullRegistryContent}\n}"

}

// Load the yaml file

import org.yaml.snakeyaml.Yaml

def loadYAML(){

    String sourcePathYAML="ci_wfo_env_test.yaml"
    File sourceFile = new File (sourcePathYAML);
    String srcFilePath = sourceFile.getCanonicalPath()
    String sourceContent = sourceFile.getText("UTF-8")
    Yaml yaml = new Yaml();
    Object data = yaml.load(sourceContent);

    logger.quiet("YAML object" + data)

}

def loadXML(String xmlSrcPath){
    def parsedXml = (new XmlParser()).parse(xmlSrcPath)
    return parsedXml
}

def getXMLComponent(Object parsedXML, String id){
    def rtnObj = null
    def foundIt = false
    parsedXML.Components.Component.each { component ->
        if (!foundIt &&(component.@id=="${id}") ) {
            rtnObj=component
            foundIt =true
        }
    }
    return rtnObj
}


