import groovy.json.JsonSlurper

buildscript {
    repositories {
        maven {
            url "${artifactory_contextUrl}/plugins-release"
            credentials {
                username = "${artifactory_user}"
                password = "${artifactory_password}"
            }
        }
    }
    dependencies {
        classpath 'com.verint.plugins:vebutu-plugin:latest.release'
        classpath 'org.yaml:snakeyaml:1.16-SNAPSHOT'
    }
}

apply plugin: 'vebutu'

ext.supportedGradleVersion = '2.3'

allprojects {
    apply plugin: 'idea'
    group = groupID
    version = currentVersion
}

repositories {
    //Resolving the artifact from the release repo, the one promoted by team
    maven {
        url "${artifactory_contextUrl}/ci-wfo-puppet-repos"
        credentials {
            username = "${artifactory_user}"
            password = "${artifactory_password}"
        }
    }
}

configurations {
    envConfig
}

dependencies {
    envConfig 'com.microsoft.technet.sysinternals:PSTools:2.11@zip'
    envConfig 'com.poweradmin:paexec:1.26@zip'
}

// prepare environment, getting the tools
task init() << {
    ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("PSTools-")}, dest: "${projectDir}\\Pstools\\")
    ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("paexec")}, dest: "${projectDir}\\PAExec\\")
}

task testPP() << {
    loadPuppetLog ("ci_wfo_env_1438279679740", "ci_wfo_env" )
    //loadPuppetLog ("ci_wfo_env_test", "ci_wfo_env_test")
    def String[] yamlFiles = "${yamlFiles}".split(',');
    yamlValidation (yamlFiles)
    extractInstalledVersion (yamlFiles, new File("${projectDir}\\PPLogs\\registryExport.json") )

    //def sviXMLObj = loadXMLObject (new File ("${projectDir}\\PPLogs\\ServerVersionInformation.xml"))

    //getVersionInstalledFromSVIXML (sviXMLObj, "Coaching Reporting")

    //renameYAML "\\\\atlpuppetmaster\\puppet_agent\\environments\\ci_wfo_env_test\\hieradata\\ci_wfo_env_test.yaml"
}

task runPuppetAgent(dependsOn: 'init') << {
    logger.quiet ("GradleUtils: Stop Watchdog service")
//	remoteService( vmIP, vmUser, vmPw, watchdogService , "stop")
    MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "stop")
    logger.quiet ("GradleUtils: run the puppet agent")
    String pp_timestamp= Calendar.getInstance().getTimeInMillis();
    // Replace the yaml content with the new build number and create the yaml file
    String certname="${environment}_${pp_timestamp}"
    logger.quiet ("GradleUtils: certname:${certname}")
    logger.quiet ("GradleUtils: run the initial set up on base environment with certname:${certname}")

    def String[] yamlFiles = "${yamlFiles}".split(',');
    yamlValidation (yamlFiles)

    String errRtnErrorCode=""
    errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "$certname","$environment_base","$vmIP","$vmUser","$vmPw")

    logger.quiet ("GradleUtils: ErrorCode - Base - ${errRtnErrorCode}")


    for (String yamlSrcPath : yamlFiles){
        if ((errRtnErrorCode=="2") ||(errRtnErrorCode=="")) {
            logger.quiet ("GradleUtils: run the setting for Yaml = ${yamlSrcPath}")
            createYAML ("${currentVersion}", "${yamlSrcPath}", "${yamlDestPath}\\${certname}.yaml")
            errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "$certname","$environment","$vmIP","$vmUser","$vmPw")
            logger.quiet ("GradleUtils: ErrorCode - ${yamlSrcPath} - ${errRtnErrorCode}")
        }
    }

    if ((errRtnErrorCode!="2") &&(errRtnErrorCode!="")) {
        logger.quiet("\nGradleUtils: ****************************************************************************")
        logger.quiet("GradleUtils: *                      ERROR ERROR IN PUPPET STEPS - COLLECTING LOGS         *")
        logger.quiet("\nGradleUtils: ****************************************************************************")
    }

    //Run by the very end for gradle tasks:
    // - publish logs
    renameYAML "${yamlDestPath}\\${certname}.yaml"
    runPuppetAgentCommand "$puppetServer", "$certname","$environment","$vmIP","$vmUser","$vmPw"


    if (loadPuppetLog( "$certname","$environment"))
        extractInstalledVersion(yamlFiles, new File("${projectDir}\\PPLogs\\registryExport.json"))

    //Now publish the error
    handlePuppetErrCode errRtnErrorCode

    if ("${deployEarFile}".toBoolean()){
        runDeployEar (vmIP, vmUser,  vmPw)
        remoteService (vmIP, vmUser,  vmPw, wfoService, "start")
    }
    //remoteService( vmIP, vmUser, vmPw, watchdogService , "start")
    MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "start")

    //wait for the application ready
    if ("${chkApp}".toBoolean())
        waitAppReady "$vmIP"



}

task deployEar(dependsOn: 'init') << {
    runDeployEar (vmIP, vmUser,  vmPw)
}

task restartWFO(dependsOn: 'init') << {
    restartRemoteService (vmIP, vmUser,  vmPw,wfoService)
}

// Handle the error return
def handlePuppetErrCode (String errCode){
    if ((errCode=="2") ||(errCode=="")){
        //do nothing
    } else if (errCode=="4") {
        throw new GradleException("GradleUtils: there were FAILURES during the transaction: exitCode (${errCode})")
        //logger.quiet ("GradleUtils: there were failures during the transaction: exitCode (${rtnCode})")
    }
    else if (errCode=="6") {
        throw new GradleException("GradleUtils: there were both changes and FAILURES during the transaction: exitCode (${errCode})")
        //logger.quiet ("GradleUtils: there were both changes and failures during the transaction: exitCode (${rtnCode})")
    }
    else {
        throw new GradleException("GradleUtils: there are FAILURES during the transaction: exitCode (${errCode})")
    }
}


// Get list of repositories from Artifactory, write the list into a file
def runPuppetAgentCommand (String iPuppetServer, String iCertName, String iEnvironment, String iVmIP, String iUser, String iPw) {
    String sCmd = ""
    // CommandLine to execute in the agent
    sCmd = "\"C:\\Program Files\\Puppet Labs\\Puppet\\bin\\puppet.bat\" agent --test --server=${iPuppetServer} --certname=${iCertName} --environment=${iEnvironment} --debug --detailed-exitcodes"

    //Create the psexec command
    // String sPsExecCmd ="cmd /c ${projectDir}\\Pstools\\PsExec.exe -accepteula \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} -h ${sCmd}"
    //String sPsExecCmd ="cmd /c ${projectDir}\\Pstools\\PsExec.exe -accepteula -i \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} -h ${sCmd}"
    String sPsExecCmd ="cmd /c ${projectDir}\\PAExec\\paexec.exe -accepteula \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} -h ${sCmd}"

    logger.quiet ("GradleUtils: the command: ${sPsExecCmd} ")

    String rtnCode=""
    try {
        exec {
            commandLine 'cmd', '/c', sPsExecCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("GradleUtils: some " + e.toString())
        rtnCode =  getRtnCode(e.toString())
    }

    logger.quiet ("GradleUtils: there were changes during the transaction: exitCode (${rtnCode})")
    //rtnCode = result.getExitValue()
    return rtnCode
    // executeOnCMDFile sPsExecCmd
    //executeAsIs sPsExecCmd
    //ppCommandFile.delete()
}

def runDeployEar ( String iVmIP, String iUser, String iPw) {
    String sCmd = ""
    // CommandLine to execute in the agent
    sCmd = "%windir%\\system32\\cscript.exe c:\\impact360\\software\\WFODeployer\\DeployWfo.vbs WLSAdmin pumpkin1 true true"

    String sPsExecCmd ="cmd /c ${projectDir}\\PAExec\\paexec.exe -accepteula \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} -h ${sCmd}"

    logger.quiet ("GradleUtils: the command: ${sPsExecCmd} ")

    String rtnCode=""
    try {
        exec {
            commandLine 'cmd', '/c', sPsExecCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("GradleUtils: some " + e.toString())
        rtnCode =  getRtnCode(e.toString())
    }

    logger.quiet ("Ear Deployment: exitCode (${rtnCode})")

    if (rtnCode!="" && rtnCode!="0" ) {
        logger.quiet ("GradleUtils: Failed with: exitCode (${rtnCode})")
        throw new GradleException("GradleUtils: Failed to deploy EAR: exitCode (${rtnCode})")
    }
}


def remoteEnableService( String iVmIP, String iUser, String iPw,String iServiceName ) {
    logger.quiet("Checking if service is disabled")
    String sPsServiceChkCmd ="cmd /c ${projectDir}\\PSTools\\psservice.exe -accepteula  \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} config \"${iServiceName}\" "
    String sPsServiceCmd ="cmd /c ${projectDir}\\PSTools\\psservice.exe -accepteula  \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} setconfig \"${iServiceName}\" auto "
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine('cmd', '/c', sPsServiceChkCmd)
            standardOutput = stdout

        }
        String out = stdout.toString()
        if (out.indexOf("DISABLED")>0) {
           logger.quiet("The service is disabled, moving it to Auto")
           try {
               exec {
                   commandLine('cmd', '/c', sPsServiceCmd)

               }
           }
           catch(Exception e){
                logger.quiet("Failed to configure ${iServiceName} ")
           }
       }
    }



    catch (Exception e) {
        logger.quiet ("Gradle Utils: Failied to read service status " + e.toString())

    }
}

def remoteService( String iVmIP, String iUser, String iPw,String iServiceName ,String iAction) {

    if (iAction.toLowerCase().contains("start")){
        remoteEnableService( iVmIP,  iUser,  iPw, iServiceName)}

    String sCmd = ""
    sCmd = "net ${iAction} \"${iServiceName}\""

    String sPsExecCmd ="cmd /c ${projectDir}\\PAExec\\paexec.exe -accepteula \\\\${iVmIP} -u ${iVmIP}\\${iUser} -p ${iPw} -h ${sCmd}"

    logger.quiet ("GradleUtils: the command RemoteService: ${sPsExecCmd} ")

    String rtnCode=""

    try {
        exec {
            commandLine('cmd', '/c', sPsExecCmd)
        }

    }

    catch (Exception e) {
        if ( e.toString().contains(("1058")))  //Service disabled

        logger.quiet ("GradleUtils: some " + e.toString())
        rtnCode =  getRtnCode(e.toString())
    }

    logger.quiet ("RemoteService: exitCode (${rtnCode})")

    if (rtnCode=="2"){
        logger.quiet ("GradleUtils: Exit code (2) keep going! ")
    }else {
        if (rtnCode != "" && rtnCode != "0") {
            logger.quiet("GradleUtils: Failed with: exitCode (${rtnCode})")
            throw new GradleException("GradleUtils: remoteService: exitCode (${rtnCode})")
        }
    }
}

def restartRemoteService( String iVmIP, String iUser, String iPw, String serviceName) {
    remoteService( iVmIP, iUser, iPw, serviceName , "stop")
    remoteService( iVmIP, iUser, iPw, serviceName , "start")
}

def MultiRemoteService(String vmIP, String vmUser, String iPw, String iServices, String iAction){
    def String[]  services= "${iServices}".split(',');
    for (String service : services){
        logger.quiet ("GradleUtils: Handling ${service}")
        remoteService( vmIP, vmUser, vmPw, service , iAction)
    }

}

def createYAML (String strReplaceWith, String sourcePathYAML, String destPathYAML) {
    // Open the
    File sourceFile = new File (sourcePathYAML);
    File destFile =  new File (destPathYAML);
    String srcFilePath = sourceFile.getCanonicalPath()
    String destFilePath = destFile.getCanonicalPath()

    String sourceContent = sourceFile.getText("UTF-8")

    logger.quiet ("GradleUtils: sourceContent YAML at ${srcFilePath}\n${sourceContent}")

    if (sourceContent.indexOf("{MasterBuildVersion}")>0) {
        sourceContent=sourceContent.replaceAll("[\${}]","HT")

        sourceContent=sourceContent.replaceAll("HTHTMasterBuildVersionHT",strReplaceWith)
    }

    logger.quiet ("GradleUtils: updatedContent YAML at ${destFilePath} \n${sourceContent}")
    destFile.write(sourceContent,"UTF-8")
}

def renameYAML (String destPathYAML) {
    // Open the

    File destFile =  new File (destPathYAML);

    String destFilePath = destFile.getCanonicalPath()
    destFile.renameTo(new File ("${destFilePath}.bak"))
}

def loadPuppetLog (String certName, String env  ){

    String logZipURL="${artifactory_contextUrl}/devops/com/verint/puppet/logs/${env}/${certName}/15.1.0.1/${certName}-15.1.0.1.zip"
    boolean rtnValue = true
    if (waitArtifactReady(logZipURL)) {
        configurations {
            logConfig
        }

        dependencies {
            logConfig "com.verint.puppet.logs.${env}:${certName}:15.1.0.1@zip"
        }

        String unzipDirPath = "${projectDir}\\PPLogs"
        def unzipDir =new File("${projectDir}\\PPLogs")
        unzipDir.mkdirs()
        //logger.quiet ("${unzipDirPath}")
        ant.unzip(src: project.configurations.logConfig.find {it.name.startsWith("${certName}-")}, dest: "${unzipDirPath}")

        logger.quiet("\nGradleUtils: ****************************************************************************")
        logger.quiet("GradleUtils: *                      LINKS TO LOG IN ARTIFACTORY                         *")
        logger.quiet("GradleUtils: *  URL: ${logZipURL}  *")
        logger.quiet("\nGradleUtils: ****************************************************************************")

        //    ant.get(src: logZipURL, dest:"${projectDir}" )
        //    ant.unzip(src:"${projectDir}\\${certName}-15.1.0.1.zip" , dest: "${projectDir}\\PPLogs\\")
        //
    }else{
        rtnValue = false
    }
    return  rtnValue
}

import org.yaml.snakeyaml.Yaml
import groovy.json.JsonSlurper
import groovy.util.XmlSlurper

def extractInstalledVersion (String [] yamlFiles, File jsRegistry){

    //load json object
    def jsRegistryObj = loadJsonObject (jsRegistry)
    def installedVersionsFile = new File ("${projectDir}\\PPLogs\\installedVersions.json")

    def sviXMLFile= new File ("${projectDir}\\PPLogs\\ServerVersionInformation.xml")
    def sviXMLObj = loadXMLObject(sviXMLFile)

    String installedVersionsContent = ""
    logger.quiet("\nGradleUtils: ****************************************************************************")
    logger.quiet("GradleUtils: *                      GETTING INSTALLED VERSION                           *")
    logger.quiet("GradleUtils: Notes: the installed version is get from registry. So if you think the version is not correct\n" +
            "GradleUtils:        Few possiblities:\n" +
            "GradleUtils:        - Your installation is failed \n" +
            "GradleUtils:        - The componentName is wrong. It need to be the same as DisplayName in registry")

    logger.quiet("GradleUtils: Getting the installed version for component listed in YAML files below:")

    yamlFiles.each { sourcePathYAML ->
        File sourceFile = new File (sourcePathYAML);
        String srcFilePath = sourceFile.getCanonicalPath()
        String sourceContent = sourceFile.getText("UTF-8")
        Yaml yaml = new Yaml();
        Object data = yaml.load(sourceContent);
        logger.quiet("GradleUtils: ${sourcePathYAML}")

        data."wfoComponents".each { wfoComponents ->
            //logger.quiet(wfoComponents)
            Map<Object> wfoComponentsMap = (Map<Object>) wfoComponents
            String componentName =""
            String installedVersion=""
            String componentGAV = ""
            String componentPC = "false"

            wfoComponentsMap.each { wfoComponent ->
                wfoComponent.each { it ->
                    logger.quiet("${it}")
                    String [] prop =    "${it}".split("=")
                    if (prop[0]=="ComponentName") {
                        componentName = prop[1]
                        installedVersion = getVersionInstalledFromRegistryJson (jsRegistryObj,prop[1] )

                        if (installedVersion=="") {
                            installedVersion = getVersionInstalledFromSVIXML (sviXMLObj,prop[1] )
                        }
                    }
                    if (prop[0]=="ComponentGAV") {
                        componentGAV = prop[1]
                    }
                    if (prop[0]=="ComponentPC") {
                        componentPC = prop[1]
                    }

                }
            }

            //logger.quiet("GradleUtils: ${componentName} : ${installedVersion} : ${componentGAV}")

            //Fill the version
            if (componentGAV!="")
                componentGAV = componentGAV.substring(0, componentGAV.lastIndexOf(":"))+ ":" + "${installedVersion}"


            if (installedVersionsContent=="") {
                installedVersionsContent ="  \"${componentName}\": {\n" +
                        "    \"ComponentName\": \"${componentName}\",\n" +
                        "    \"InstalledVersion\": \"${installedVersion}\",\n" +
                        "    \"ComponentGAV\": \"${componentGAV}\",\n" +
                        "    \"ComponentPC\": \"${componentPC}\"\n" +
                        "  }"
            }else{
                installedVersionsContent =installedVersionsContent +",\n  \"${componentName}\": {\n" +
                        "    \"ComponentName\": \"${componentName}\",\n" +
                        "    \"InstalledVersion\": \"${installedVersion}\",\n" +
                        "    \"ComponentGAV\": \"${componentGAV}\",\n" +
                        "    \"ComponentPC\": \"${componentPC}\"\n" +
                        "  }"
            }

        }
    }

    installedVersionsFile.write "{\n${installedVersionsContent}\n}"
    logger.quiet("\nGradleUtils: ****************************************************************************")
    logger.quiet("GradleUtils: *                      IMPORTANCE - INSTALLED VERSION                      *")
    logger.quiet("GradleUtils: ****************************************************************************")
    logger.quiet(installedVersionsFile.text)
    logger.quiet("GradleUtils: ****************************************************************************\n")
    logger.quiet("GradleUtils: ..\\PPLogs\\installedVersions.json *****************\n")
}

def getVersionInstalledFromRegistryJson (Object jsonObject, String componentName){
    def found = false;
    String rtnVersion = ""
    jsonObject.each { registryItem ->
        //logger.quiet("" + registryItem.getValue())
        def registryItemValue = registryItem.getValue()
        String regComponentName =registryItemValue."ComponentName"
        if ((regComponentName == componentName) && !found) {
            rtnVersion =  registryItemValue."InstalledVersion"
            found = true
        }
    }
    return      rtnVersion
}

def getVersionInstalledFromSVIXML (Object xmlObject, String componentName){
    def found = false;
    String rtnVersion = ""

    xmlObject."Components"."Component".each { xmlItem ->
        //logger.quiet("${xmlItem}")
        //logger.quiet("name:" + xmlItem.@name + " version:" + xmlItem.@version)
        if ((xmlItem.@name == componentName) && !found) {
            logger.quiet("name:" + xmlItem.@name + " version:" + xmlItem.@version)
            rtnVersion =  xmlItem.@version
            found = true
        }
    }
    return rtnVersion
}

def loadJsonObject(File jsonFile) {
    def InputJSON = new JsonSlurper().parseText(jsonFile.text)

    return InputJSON
}

def loadXMLObject(File xmlFile) {

    def rtnXML = null

    //logger.quiet (xmlFile.text)
    try {
        //rtnXML = new XmlSlurper().parseText(xmlFile.text)
        rtnXML = new XmlParser().parseText(xmlFile.text)
    }catch (Exception e){
        logger.quiet("\nGradleUtils: XML doesn't exist or wrong format :" + xmlFile.getAbsolutePath())
        logger.quiet("${e}")
        rtnXML = null
    }
    return rtnXML
}


def getRtnCode (String strException) {
    int lastIndex =   strException.lastIndexOf("exit value")
    String strReturn=""
    if (lastIndex>0) {
        strReturn =   strException.substring(lastIndex+ "exit value".length()+1)
        //logger.quiet ("GradleUtils: strReturn=->${strReturn}<-")
    }
    return strReturn;
}

def executeOnCMDFile(String command) {
    File temp = File.createTempFile("cish",".bat");
    temp.write(command)
    //println "             *************Temp command: ******:" + temp.getAbsolutePath()

    String filePath = temp.getAbsolutePath()
    //filePath = filePath.replaceAll("\\\\","/")
    println "             *************Temp command: ******:" + filePath

    executeOnCMD filePath
    //TODO: uncomment code bellow
    //temp.delete()
}

def executeOnCMD(String command) {
    return executeOnCMD(command, new File(System.properties.'java.io.tmpdir'))
}

def executeOnCMD (String command, File workingDir) {
    println "---CommandToExecute:" + command
    def process = new ProcessBuilder(command)
            .directory(workingDir)
            .redirectErrorStream(true)
            .start()
    process.inputStream.eachLine {println it}
    //With the paexec , no need to waitFor
    //process.waitFor();
    //return process.exitValue()
}

def executeOnShellFile(String command) {
    File temp = File.createTempFile("cish",".sh");
    temp.write(command)
    //println "             *************Temp command: ******:" + temp.getAbsolutePath()

    String filePath = temp.getAbsolutePath()
    //filePath = filePath.replaceAll("\\\\","/")
    println "             *************Temp command: ******:" + filePath

    executeOnShell filePath
    //TODO: uncomment code bellow
    //temp.delete()
}

def executeOnShell(String command) {
    return executeOnShell(command, new File(System.properties.'java.io.tmpdir'))
}

def executeOnShell(String command, File workingDir) {
    println "---CommandToExecute:" + command
    def process = new ProcessBuilder(addShellPrefix(command))
            .directory(workingDir)
            .redirectErrorStream(true)
            .start()
    process.inputStream.eachLine {println it}
    process.waitFor();
    return process.exitValue()
}

def addShellPrefix(String command) {
    def commandArray = new String[3]
    commandArray[0] = "sh"
    commandArray[1] = "-c"
    commandArray[2] = command
    return commandArray
}

//Execute directly

def executeAsIs(String command) {
    println "---CommandAsIsToExecute:" + command
    def process = "$command".execute()
    process.text.eachLine {println it}
    process.waitFor();
    return process.exitValue()
}

def boolean containsPrefixes(String srcString, String prefixes) {
    def prefixesList= prefixes.split("##")
    //println ("    -------Check if : " + srcString + " has the :" + prefixes)
    boolean hasIt=false
    for (int i=0; i< prefixesList.length; i++) {
        String strTest=prefixesList[i]
        //println (" -------strTest: " + strTest)
        if (srcString.contains(strTest)) {
            hasIt = true
            break
        }
    }

    return hasIt
}

def waitAppReady (String vmIP) {
    logger.quiet ("-----Start wait login page-----")

    //waits up to 10 minutes (and checks every 500 milliseconds) for a web server on vmIP to serve up the specified URL.
    ant.waitfor (maxwait:"10", maxwaitunit:"minute", checkevery:"500", timeoutproperty:"web.timeout") {
        http (url:"http://${vmIP}/wfo/control/signin")
    }
    ant.fail (message:"Can't display the WFO Login page, time out!", if:"web.timeout")
    logger.quiet("-----Login: READY-----")
}


def waitArtifactReady (String aURL) {
    logger.quiet ("-----Waiting for aURL available ${aURL} : -----")
    boolean rtnSuccess = true
    //waits up to 10 minutes (and checks every 500 milliseconds) for a web server on vmIP to serve up the specified URL.
    ant.waitfor (maxwait:"3", maxwaitunit:"minute", checkevery:"500", timeoutproperty:"web.timeout") {
        http (url:"${aURL}")
    }
    try {
        ant.fail (message:"Can't find", if:"web.timeout")
    }catch (Exception e){
        rtnSuccess = false
    }

    return    rtnSuccess
}

def yamlValidation(String [] yamlFiles){
    yamlFiles.each { yamlFile ->
        def yaml = new Yaml()
        def doc = new File(yamlFile).text
        try {
            def map = (Map) yaml.load(doc)
            logger.quiet ("GradleUtils: YAML (${yamlFile}) PASSED validation")
        }catch (Exception e){
            logger.quiet ("GradleUtils: Invalid YAML (${yamlFile})")
            throw new GradleException("GradleUtils:  (${e})")
        }
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = supportedGradleVersion
}


//reference
