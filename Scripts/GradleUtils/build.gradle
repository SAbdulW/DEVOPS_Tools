import groovy.json.JsonSlurper

buildscript {
    repositories {
        maven {
            url "${artifactory_contextUrl}/plugins-release"
            credentials {
                username = "${artifactory_user}"
                password = "${artifactory_password}"
            }
        }
    }
    dependencies {
        classpath 'com.verint.plugins:vebutu-plugin:latest.release'
        classpath 'org.yaml:snakeyaml:1.16-SNAPSHOT'
        classpath 'com.github.sarxos:windows-registry-util:latest.release'
        classpath(group: 'org.jfrog.buildinfo', name: 'build-info-extractor-gradle', version: '2.2.4')
    }
}

apply plugin: 'vebutu'
apply plugin: 'artifactory'
apply plugin: 'java'

ext.supportedGradleVersion = '2.3'

allprojects {
    apply plugin: 'idea'
    group = "com.verint.puppet.logs.${environment}"
    version = currentVersion
}
// Only applicable when runLocalDeploy
archivesBaseName = "${icertname}"
def zipFile = file("$buildDir/pplog.zip")
artifacts {
    archives file: zipFile, name: "${archivesBaseName}", type: 'zip'
}

repositories {
    //Resolving the artifact from the release repo, the one promoted by team
    maven {
        url "${artifactory_contextUrl}/ci-wfo-puppet-repos"
        credentials {
            username = "${artifactory_user}"
            password = "${artifactory_password}"
        }
    }
}

configurations {
    envConfig
}

dependencies {
    envConfig 'com.microsoft.technet.sysinternals:PSTools:2.11@zip'
    envConfig 'com.poweradmin:paexec:1.26@zip'
}

def domainPattern =/.*['\\'@].*/

// prepare environment, getting the tools
task init() << {

    logger.quiet ("GradleUtils: Version updated by April 23 2018 - 3.03 - Update to sustains the version put for new YAML")

    ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("PSTools-")}, dest: "${projectDir}\\Pstools\\")
    ant.unzip(src: project.configurations.envConfig.find {it.name.startsWith("paexec")}, dest: "${projectDir}\\PAExec\\")
    if  (!vmUser.matches(domainPattern)) {
        println "vmUser is not in a domain format. iVmIP was added as a prefix. "
        vmUser = "${vmIP}\\${vmUser}"
        println "vmUser = ${vmUser}"

    }
}


task testPP() << {
    //loadPuppetLog ("ci_wfo_env_1438279679740", "ci_wfo_env" )
    //loadPuppetLog ("ci_wfo_env_test", "ci_wfo_env_test")
    //def String[] yamlFiles = "${yamlFiles}".split(',');
    //yamlValidation (yamlFiles)
    //extractInstalledVersion (yamlFiles, new File("${projectDir}\\PPLogs\\registryExport.json") )

    //def sviXMLObj = loadXMLObject (new File ("${projectDir}\\PPLogs\\ServerVersionInformation.xml"))

    //getVersionInstalledFromSVIXML (sviXMLObj, "Coaching Reporting")

    //renameYAML "\\\\atlpuppetmaster\\puppet_agent\\environments\\ci_wfo_env_test\\hieradata\\ci_wfo_env_test.yaml"
//    logger.quiet ("GradleUtils: Filling the version range to YAML files: ${yamlFiles}")
//    if ("${fillVersionRange}".toBoolean())
//        fillSpecificVersionYAMLs "$yamlFiles"
    runLogCollectionLocal ("ci_wfo_env_1459358138028", "ci_wfo_env")

}

task runPuppetAgent(dependsOn: 'init') << {

    noticeLog("GradleUtils: The full flow as below\n" +
            "Stage 1: \n" +
            "- 1.1 - Check the YAML file and fill the version as needed [SLAVE]\n" +
            "- 1.2 - Stop the services on remote machine with remote call[REMOTE]\n" +
            "- 1.3 - Generate the puppet certificate [SLAVE]\n" +
            "\n" +
            "Stage 2: \n" +
            "- 2.1 - Run puppet to prepare the environements in remote machine[REMOTE]\n" +
            "\n" +
            "Stage 3:\n" +
            "- 3.1 - Run puppet to setup (uninstall, install or do both) the msi(s) [REMOTE]\n" +
            "\t\tfor each defined yaml\n" +
            "Stage 4: If the Stage 3 is success, else go to stage 5\n" +
            "- 4.1 - Run deploy the ear (if there is the need) with cscripts [REMOTE] \n" +
            "- 4.2 - Start the services on remote remote machine with remote call[REMOTE]\n" +
            "- 4.3 - Check and wait until the login page come up\n" +
            "Stage 5: Collect logs\n" +
            "- 5.1 - Collecting the logs from remote machine with puppet [REMOTE]\n" +
            "- 5.2 - Extract and fill the installed version to : PPLogs\\installedVersions.json")

    if ("${fillVersionRange}".toBoolean()) {
        noticeLog ("GradleUtils: Stage 1.1: Check the YAML file and fill the version as needed [SLAVE]: ${yamlFiles}")
        fillSpecificVersionYAMLs "$yamlFiles"
    }

    noticeLog ("GradleUtils: Stage 1.2: Stop the services on remote machine with remote call[REMOTE]")
    logger.quiet ("GradleUtils: Stop Watchdog service")
//	remoteService( vmIP, vmUser, vmPw, watchdogService , "stop")
    MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "stop")
    logger.quiet ("GradleUtils: run the puppet agent")
    String pp_timestamp= Calendar.getInstance().getTimeInMillis();
    // Replace the yaml content with the new build number and create the yaml file
    String certname="${environment}_${pp_timestamp}"
    noticeLog ("GradleUtils: Stage 1.3: Generate the puppet certificate [SLAVE]")
    logger.quiet ("GradleUtils: certname:${certname}")

    noticeLog ("GradleUtils: Stage 2.1: Run puppet to prepare the environements in remote machine[REMOTE]")
    logger.quiet ("GradleUtils: run the initial set up on base environment with certname:${certname}")

    def String[] yamlFiles = "${yamlFiles}".split(',');
    yamlValidation (yamlFiles)

    String errRtnErrorCode=""
    errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "$certname","$environment_base","$vmIP","$vmUser","$vmPw")

    logger.quiet ("GradleUtils: ErrorCode - Base - ${errRtnErrorCode}")
    noticeLog ("GradleUtils: Stage 3.1: Run puppet to setup (uninstall, install or do both) the msi(s) [REMOTE]\n" +
            "\t\tfor each defined yaml")

    for (String yamlSrcPath : yamlFiles){
        if ((errRtnErrorCode=="2") ||(errRtnErrorCode=="")) {
            logger.quiet ("GradleUtils: run the setting for Yaml = ${yamlSrcPath}")
            createYAML ("${currentVersion}", "${yamlSrcPath}", "${yamlDestPath}\\${certname}.yaml")
            errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "$certname","$environment","$vmIP","$vmUser","$vmPw")
            logger.quiet ("GradleUtils: ErrorCode - ${yamlSrcPath} - ${errRtnErrorCode}")
        }
    }

    noticeLog ("GradleUtils: Stage 4: If the Stage 3 is success, else go to stage 5")
    if ((errRtnErrorCode!="2") &&(errRtnErrorCode!="")) {
        logger.quiet("\nGradleUtils: ****************************************************************************")
        logger.quiet("GradleUtils: *                      ERROR ERROR IN PUPPET STEPS - COLLECTING LOGS         *")
        logger.quiet("\nGradleUtils: ****************************************************************************")
    }else{
        try {
            //Move to this to have the puppet log capture
            if ("${deployEarFile}".toBoolean()){

                noticeLog ("GradleUtils: Stage 4.1 - Run deploy the ear (if there is the need) with cscripts [REMOTE]")

                runDeployEar (vmIP, vmUser,  vmPw)

                noticeLog ("GradleUtils: Stage 4.2 - Start the services on remote remote machine with remote call[REMOTE]")

                remoteService (vmIP, vmUser,  vmPw, wfoService, "start")
            }

            noticeLog ("GradleUtils: Stage 4.2 - Start the services on remote remote machine with remote call[REMOTE]")
            //remoteService( vmIP, vmUser, vmPw, watchdogService , "start")
            MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "start")

            /* [Chau] temporarily comment this out to debug an issue
            //wait for the application ready
            noticeLog ("GradleUtils: Stage 4.3 - Check and wait until the login page come up [SLAVE]")
            if ("${chkApp}".toBoolean())
                waitAppReady "$vmIP"
            */
        } catch (Exception e) {
            logger.quiet("\nGradleUtils:runPuppetAgent ****************************************************************************")
            logger.quiet ("GradleUtils:runPuppetAgent - ERROR:" + e.toString())
            logger.quiet("\nGradleUtils:runPuppetAgent ****************************************************************************")
            errRtnErrorCode = getRtnCode(e.toString())
            if ((errRtnErrorCode!="2") &&(errRtnErrorCode!="")){
            }else{
                errRtnErrorCode="99"
            }
        }
    }
    //Run by the very end for gradle tasks:
    // - publish logs
    noticeLog ("GradleUtils: Stage 5.1 - Collecting the logs from remote machine with puppet [REMOTE]")

    renameYAML "${yamlDestPath}\\${certname}.yaml"
    runPuppetAgentCommand("$puppetServer", "$certname","$environment","$vmIP","$vmUser","$vmPw")

    noticeLog ("GradleUtils: Stage 5.2 - Extract and fill the installed version to : PPLogs\\installedVersions.json")

    if (loadPuppetLog( "$certname","$environment"))
        extractInstalledVersion(yamlFiles, new File("${projectDir}\\PPLogs\\registryExport.json"))
    //Now publish the error
    handlePuppetErrCode errRtnErrorCode

    noticeLog ("GradleUtils: DONE!!!")

}

task  extractInstalledVersionToFile ()<< {
    def String[] yamlFiles = "${yamlFiles}".split(',');
    yamlValidation (yamlFiles)
    extractInstalledVersion(yamlFiles, new File("${registryExportFile}"))
}

task deployEar(dependsOn: 'init') << {
    runDeployEar (vmIP, vmUser,  vmPw)
}

task restartWFO(dependsOn: 'init') << {
    restartRemoteService (vmIP, vmUser,  vmPw,wfoService)
}

// Handle the error return
def handlePuppetErrCode (String errCode){
    noticeLog ("Returned Code from Puppet: ${errCode}")
    if ((errCode=="2") ||(errCode=="")){
        //do nothing
    } else if (errCode=="4") {
        throw new GradleException("GradleUtils: there were FAILURES during the transaction: exitCode (${errCode})")
        //logger.quiet ("GradleUtils: there were failures during the transaction: exitCode (${rtnCode})")
    }
    else if (errCode=="6") {
        throw new GradleException("GradleUtils: there were both changes and FAILURES during the transaction: exitCode (${errCode})")
        //logger.quiet ("GradleUtils: there were both changes and failures during the transaction: exitCode (${rtnCode})")
    }
    else {
        throw new GradleException("GradleUtils: there are FAILURES during the transaction: exitCode (${errCode})")
    }
}
def String runRemote(String sPrefix, String sCommand, String iVmIP, String iUser, String iPw){

    String sExecCmd = generateRemoteCmd (sPrefix,sCommand, iVmIP,iUser,iPw)

    logger.quiet ("GradleUtils: the command: ${sExecCmd} ")

    String rtnCode = ""
    try {
        exec {
            commandLine 'cmd', '/c', sExecCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("GradleUtils: some " + e.toString())
        rtnCode = getRtnCode(e.toString())
    }

    logger.quiet ("GradleUtils: there were changes during the transaction: exitCode (${rtnCode})")
    //rtnCode = result.getExitValue()
    return rtnCode

}

def String runRemoteNonIteractive(String sCommand, String iVmIP, String iUser, String iPw){

    String sExecCmd = generateRemoteCmdPsExecNonInteractive(sCommand, iVmIP,iUser,iPw)

    logger.quiet ("GradleUtils: the command: ${sExecCmd} ")

    String rtnCode = ""
    try {
        exec {
            commandLine 'cmd', '/c', sExecCmd
        }
    }
    catch (Exception e) {
        logger.quiet ("GradleUtils: some " + e.toString())
        rtnCode = getRtnCode(e.toString())
    }

    logger.quiet ("GradleUtils: there were changes during the transaction: exitCode (${rtnCode})")
    //rtnCode = result.getExitValue()
    return rtnCode

}

def String generateRemoteCmd(String sPrefix, String sCommand, String iVmIP, String iUser, String iPw){

    String strExecCmd = ""
    String sRemoteCommand = "${remoteCmd}"
    if (sRemoteCommand.equalsIgnoreCase("psexec")){
        strExecCmd = generateRemoteCmdPsExec(sCommand,iVmIP,iUser,iPw)
    }else if (sRemoteCommand.equalsIgnoreCase("psexecfile")){
        strExecCmd = generateRemoteCmdPsExecFile(sPrefix,sCommand,iVmIP,iUser,iPw)
    }else if (sRemoteCommand.equalsIgnoreCase("local")){
        strExecCmd = sCommand
    }else if (sRemoteCommand.equalsIgnoreCase("localfile")){
        strExecCmd = generateLocalCmdFile(sPrefix,sCommand,iVmIP,iUser,iPw)
    }else{
        strExecCmd = generateRemoteCmdPaExec(sCommand,iVmIP,iUser,iPw)
    }
    return strExecCmd
}

def String generateRemoteCmdPsExecNonInteractive(String sCommand, String iVmIP, String iUser, String iPw){

    //String strExecCmd = "cmd /c .\\PSTools\\psexec.exe -accepteula \\\\${iVmIP} -s -u ${iUser} -p ${iPw} -w ${sWorkDir} -h -d ${sCommand}"
    String strExecCmd = "cmd /c .\\PSTools\\psexec.exe -accepteula \\\\${iVmIP} -u ${iUser} -p ${iPw} -h -d ${sCommand}"
    return strExecCmd;
}

def String generateRemoteCmdPsExec(String sCommand, String iVmIP, String iUser, String iPw){

    //String strExecCmd = "cmd /c .\\PSTools\\psexec.exe -accepteula \\\\${iVmIP} -s -u ${iUser} -p ${iPw} -w ${sWorkDir} -h ${sCommand}"
    String strExecCmd = "cmd /c .\\PSTools\\psexec.exe -accepteula \\\\${iVmIP} -u ${iUser} -p ${iPw} -h ${sCommand}"
    return strExecCmd;
}

def String generateRemoteCmdPsExecFile(String sPrefix,String sCommand, String iVmIP, String iUser, String iPw){

    //GEnerate the bat file
    File batchFile = File.createTempFile("puppet",".bat");

    String strDataDir=System.getenv("IMPACT360DATADIR")
    if (!strDataDir) strDataDir="${impact360DataDir}"

    String strFileName= batchFile.getName()
    String strShortName= strFileName.replaceFirst(~/\.[^\.]+$/, '')
    String strContent = sCommand + " 1>> ${strDataDir}\\Logs\\${sPrefix}_${strShortName}.log 2>&1"
    batchFile.write(strContent)

    logger.quiet ("GradleUtils: Batch file content to execute remotely:  (${strFileName}) \n ${strContent}")

    String strExecCmd = "cmd /c .\\PSTools\\psexec.exe -accepteula \\\\${iVmIP} -s -u ${iUser} -p ${iPw} -w ${sWorkDir} -c \"${batchFile.getAbsolutePath()}\""

    return strExecCmd;

}

def String generateLocalCmdFile(String sPrefix,String sCommand, String iVmIP, String iUser, String iPw){

    //GEnerate the bat file
    File batchFile = File.createTempFile("puppet",".bat");
    String strDataDir=System.getenv("IMPACT360DATADIR")
    if (!strDataDir) strDataDir="${impact360DataDir}"

    String strFileName= batchFile.getName()
    String strShortName= strFileName.replaceFirst(~/\.[^\.]+$/, '')
    sCommand =  sCommand + " 1>> ${strDataDir}\\Logs\\${sPrefix}_${strShortName}.log 2>&1"

    return sCommand;

}


def String generateRemoteCmdPaExec(String sCommand, String iVmIP, String iUser, String iPw){

    String strExecCmd = "cmd /c .\\PAExec\\paexec.exe -accepteula \\\\${iVmIP} -u ${iUser} -p ${iPw} -h ${sCommand}"
    return strExecCmd;
}


// Get list of repositories from Artifactory, write the list into a file
def runPuppetAgentCommand (String iPuppetServer, String iCertName, String iEnvironment, String iVmIP, String iUser, String iPw) {
    String sCmd
    // CommandLine to execute in the agent
    sCmd = "\"C:\\Program Files\\Puppet Labs\\Puppet\\bin\\puppet.bat\" agent --test --server=${iPuppetServer} --certname=${iCertName} --environment=${iEnvironment} --debug --detailed-exitcodes"

    String rtnCode = runRemote ("runPuppetAgent",sCmd, iVmIP,iUser,iPw)
    return rtnCode
}

def runDeployEar (String iVmIP, String iUser, String iPw) {
    String sCmd
    // CommandLine to execute in the agent
    String strSoftwareDir=System.getenv("IMPACT360SOFTWAREDIR")
    if (!strSoftwareDir) strSoftwareDir = "${impact360SoftwareDir}"


    sCmd = "%windir%\\system32\\cscript.exe ${strSoftwareDir}\\WFODeployer\\DeployWfo.vbs WLSAdmin pumpkin1 true true"

    String rtnCode = runRemote ("runDeployEar",sCmd, iVmIP,iUser,iPw)
    logger.quiet ("Ear Deployment: exitCode (${rtnCode})")

    if (rtnCode!="" && rtnCode!="0" ) {
        logger.quiet ("GradleUtils: Failed with: exitCode (${rtnCode})")
        throw new GradleException("GradleUtils: Failed to deploy EAR: exitCode (${rtnCode})")
    }
}


def remoteEnableService(String iVmIP, String iUser, String iPw,String iServiceName ) {
    logger.quiet("Checking if service is disabled")

    String sServiceChkCmd = "cmd /c .\\PSTools\\psservice.exe -accepteula \\\\${iVmIP} -u ${iUser} -p ${iPw} -w ${sWorkDir} config \"${iServiceName}\" "
    String sServiceCmd = "cmd /c .\\PSTools\\psservice.exe -accepteula \\\\${iVmIP} -u ${iUser} -p ${iPw} -w ${sWorkDir} setconfig \"${iServiceName}\" auto "

    String sRemoteCommand = "${remoteCmd}"
    if (sRemoteCommand.equalsIgnoreCase("local")){
        sServiceChkCmd = "config \"${iServiceName}\" "
        sServiceCmd = "setconfig \"${iServiceName}\" auto "
    }

    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine('cmd', '/c', sServiceChkCmd)
            standardOutput = stdout
        }
        String out = stdout.toString()
        if (out.indexOf("DISABLED")>0) {
            logger.quiet("The service is disabled, moving it to Auto")
            try {
                exec {
                    commandLine('cmd', '/c', sServiceCmd)
                }
            }
            catch(Exception e){
                logger.quiet("Failed to configure ${iServiceName} ")
            }
        }
    }
    catch (Exception e) {
        logger.quiet ("Gradle Utils: Failied to read service status " + e.toString())
    }
}

def remoteService(String iVmIP, String iUser, String iPw, String iServiceName, String iAction) {
    if (iAction.toLowerCase().contains("start")){
        remoteEnableService( iVmIP,  iUser,  iPw, iServiceName)}

    String sCmd
    sCmd = "net ${iAction} \"${iServiceName}\""

    String rtnCode = runRemote ("remoteService",sCmd, iVmIP,iUser,iPw)

    logger.quiet ("RemoteService: exitCode (${rtnCode})")

    if (rtnCode=="2"){
        logger.quiet ("GradleUtils: Exit code (2) keep going! ")
    }else {
        if (rtnCode != "" && rtnCode != "0") {
            logger.quiet("GradleUtils: Failed with: exitCode (${rtnCode})")
            throw new GradleException("GradleUtils: remoteService: exitCode (${rtnCode})")
        }
    }
}

def restartRemoteService( String iVmIP, String iUser, String iPw, String serviceName) {
    remoteService( iVmIP, iUser, iPw, serviceName , "stop")
    remoteService( iVmIP, iUser, iPw, serviceName , "start")
}

def MultiRemoteService(String vmIP, String vmUser, String iPw, String iServices, String iAction){
    def String[]  services= "${iServices}".split(',');
    for (String service : services){
        logger.quiet ("GradleUtils: Handling ${service}")
        remoteService( vmIP, vmUser, vmPw, service , iAction)
    }
}

def createYAML (String strReplaceWith, String sourcePathYAML, String destPathYAML) {
    // Open the
    File sourceFile = new File (sourcePathYAML);
    File destFile =  new File (destPathYAML);
    String srcFilePath = sourceFile.getCanonicalPath()
    String destFilePath = destFile.getCanonicalPath()
    String strArtifactoryRepo = "${componentRepoDefault}"

    String sourceContent = sourceFile.getText("UTF-8")

    logger.quiet ("GradleUtils: sourceContent YAML at ${srcFilePath}\n${sourceContent}")

    if (sourceContent.indexOf("{MasterBuildVersion}")>0) {
        sourceContent=sourceContent.replaceAll("[\${}]","HT")

        sourceContent=sourceContent.replaceAll("HTHTMasterBuildVersionHT",strReplaceWith)
    }

    String strToBeReplaceWith = "---\nartifactory_repo   : '${strArtifactoryRepo}'\n\n"
    sourceContent=sourceContent.replaceAll("---",strToBeReplaceWith)

    logger.quiet ("GradleUtils: updatedContent YAML at ${destFilePath} \n${sourceContent}")
    destFile.write(sourceContent,"UTF-8")
}

def renameYAML (String destPathYAML) {
    // Open the

    File destFile =  new File (destPathYAML);

    String destFilePath = destFile.getCanonicalPath()
    destFile.renameTo(new File ("${destFilePath}.bak"))
}

def loadPuppetLog (String certName, String env  ){

    String logZipURL="${artifactory_contextUrl}/devops/com/verint/puppet/logs/${env}/${certName}/${currentVersion}/${certName}-${currentVersion}.zip"
    boolean rtnValue = true
    if (waitArtifactReady(logZipURL)) {

//        configurations {
//            logConfig
//        }
//
//        dependencies {
//            logConfig "com.verint.puppet.logs.${env}:${certName}:${currentVersion}@zip"
//        }

        String unzipDirPath = "${projectDir}\\PPLogs"
        def unzipDir = new File("${projectDir}\\PPLogs")
        unzipDir.mkdirs()
        //logger.quiet ("${unzipDirPath}")
        ant.get(src: "${logZipURL}", dest: "${projectDir}\\${certName}.zip", skipexisting: 'true')
        ant.unzip(src: "${projectDir}\\${certName}.zip", dest: "${unzipDirPath}")


        // ant.unzip(src: project.configurations.logConfig.find {it.name.startsWith("${certName}-")}, dest: "${unzipDirPath}")

        logger.quiet("\nGradleUtils: ****************************************************************************")
        logger.quiet("GradleUtils: *                      LINKS TO LOG IN ARTIFACTORY                         *")
        logger.quiet("GradleUtils: *  URL: ${logZipURL}  *")
        logger.quiet("\nGradleUtils: ****************************************************************************")

        //    ant.get(src: logZipURL, dest:"${projectDir}" )
        //    ant.unzip(src:"${projectDir}\\${certName}-15.1.0.1.zip" , dest: "${projectDir}\\PPLogs\\")
        //
    }else{
        rtnValue = false
    }
    return  rtnValue
}

import org.yaml.snakeyaml.Yaml
import groovy.json.JsonSlurper
import groovy.util.XmlSlurper
import java.util.regex.*;

def extractInstalledVersion (String [] yamlFiles, File jsRegistry){

    //load json object
    def jsRegistryObj = loadJsonObject (jsRegistry)
    def installedVersionsFile = new File ("${projectDir}\\PPLogs\\installedVersions.json")

    def sviXMLFile = new File ("${projectDir}\\PPLogs\\ServerVersionInformation.xml")
    def sviXMLObj = loadXMLObject(sviXMLFile)

    String installedVersionsContent = ""
    logger.quiet("\nGradleUtils: ****************************************************************************")
    logger.quiet("GradleUtils: *                      GETTING INSTALLED VERSION                           *")
    logger.quiet("GradleUtils: Notes: the installed version is get from registry. So if you think the version is not correct\n" +
            "GradleUtils:        Few possiblities:\n" +
            "GradleUtils:        - Your installation is failed \n" +
            "GradleUtils:        - The componentName is wrong. It need to be the same as DisplayName in registry")

    logger.quiet("GradleUtils: Getting the installed version for component listed in YAML files below:")

    yamlFiles.each { sourcePathYAML ->
        File sourceFile = new File (sourcePathYAML);
        String srcFilePath = sourceFile.getCanonicalPath()
        String sourceContent = sourceFile.getText("UTF-8")
        Yaml yaml = new Yaml();
        Object data = yaml.load(sourceContent);
        logger.quiet("GradleUtils: ${sourcePathYAML}")

        data."wfoComponents".each { wfoComponents ->
            //logger.quiet(wfoComponents)
            Map<Object> wfoComponentsMap = (Map<Object>) wfoComponents
            String componentName =""
            String installedVersion=""
            String componentGAV = ""
            String componentPC = "false"

            wfoComponentsMap.each { wfoComponent ->
                wfoComponent.each { it ->
                    logger.quiet("${it}")
                    String [] prop =    "${it}".split("=")
                    if (prop[0]=="ComponentName") {
                        componentName = prop[1]
                        installedVersion = getVersionInstalledFromRegistryJson (jsRegistryObj,prop[1] )

                        if (installedVersion=="") {
                            installedVersion = getVersionInstalledFromSVIXML (sviXMLObj,prop[1] )
                        }
                    }
                    if (prop[0]=="ComponentGAV") {
                        componentGAV = prop[1]
                    }
                    if (prop[0]=="ComponentPC") {
                        componentPC = prop[1]
                    }

                }
            }

            //logger.quiet("GradleUtils: ${componentName} : ${installedVersion} : ${componentGAV}")

            //Fill the version
            if (componentGAV!="")
                componentGAV = componentGAV.substring(0, componentGAV.lastIndexOf(":"))+ ":" + "${installedVersion}"


            if (installedVersionsContent=="") {
                installedVersionsContent ="  \"${componentName}\": {\n" +
                        "    \"ComponentName\": \"${componentName}\",\n" +
                        "    \"InstalledVersion\": \"${installedVersion}\",\n" +
                        "    \"ComponentGAV\": \"${componentGAV}\",\n" +
                        "    \"ComponentPC\": \"${componentPC}\"\n" +
                        "  }"
            }else{
                installedVersionsContent =installedVersionsContent +",\n  \"${componentName}\": {\n" +
                        "    \"ComponentName\": \"${componentName}\",\n" +
                        "    \"InstalledVersion\": \"${installedVersion}\",\n" +
                        "    \"ComponentGAV\": \"${componentGAV}\",\n" +
                        "    \"ComponentPC\": \"${componentPC}\"\n" +
                        "  }"
            }

        }
    }

    installedVersionsFile.write "{\n${installedVersionsContent}\n}"
    logger.quiet("\nGradleUtils: ****************************************************************************")
    logger.quiet("GradleUtils: *                      IMPORTANCE - INSTALLED VERSION                      *")
    logger.quiet("GradleUtils: ****************************************************************************")
    logger.quiet(installedVersionsFile.text)
    logger.quiet("GradleUtils: ****************************************************************************\n")
    logger.quiet("GradleUtils: ..\\PPLogs\\installedVersions.json *****************\n")
}

def getVersionInstalledFromRegistryJson (Object jsonObject, String componentName){
    def found = false;
    String rtnVersion = ""
    logger.quiet("Search Registry file for: ${componentName}")
    
    // first try - exact name
    jsonObject.each { registryItem ->
        //logger.quiet("" + registryItem.getValue())
        def registryItemValue = registryItem.getValue()
        String regComponentName =registryItemValue."ComponentName"
        
        if ((regComponentName.toUpperCase() == componentName.toUpperCase()) && !found){
            rtnVersion =  registryItemValue."InstalledVersion"
            found = true
            logger.quiet("FOUND: ${rtnVersion}")
            return rtnVersion
        }
    }
    logger.quiet("Could not find exact name of: ${componentName} in Registry")


    // second try
    jsonObject.each { registryItem ->
        //logger.quiet("" + registryItem.getValue())
        def registryItemValue = registryItem.getValue()
        String regComponentName =registryItemValue."ComponentName"
        
        if(checkComponentName(componentName, regComponentName) && !found) {
            rtnVersion =  registryItemValue."InstalledVersion"
            found = true
            logger.quiet("FOUND: ${rtnVersion}")
            return rtnVersion
        }
    }

    logger.quiet("Search Registry file for: ${componentName} - Found: ${rtnVersion}")
    return rtnVersion
}

def checkComponentName(String name1, String name2){
    if(name1.toUpperCase() == name2.toUpperCase()){
        return true
    }
    else if(name1.toUpperCase().contains(name2.toUpperCase())){
        return true
    }
    else if(name2.toUpperCase().contains(name1.toUpperCase())){
        return true
    }

    return false
}

def getVersionInstalledFromSVIXML (Object xmlObject, String componentName){
    def found = false;
    String rtnVersion = ""

    xmlObject."Components"."Component".each { xmlItem ->
        //logger.quiet("${xmlItem}")
        //logger.quiet("name:" + xmlItem.@name + " version:" + xmlItem.@version)
        if ((xmlItem.@name == componentName) && !found) {
            logger.quiet("name:" + xmlItem.@name + " version:" + xmlItem.@version)
            rtnVersion =  xmlItem.@version
            found = true
        }
    }
    return rtnVersion
}


// General function
def fillSpecificVersionYAMLs (String iYamlFiles){
    //base on the GAV input, to get the specific version from artifactory and update the YAML
    def String[] yamlFiles = "${iYamlFiles}".split(',');
    yamlValidation (yamlFiles)
    for (String yamlSrcPath : yamlFiles) {
        fillSpecificVersionYAML (yamlSrcPath)
    }
}

def fillSpecificVersionYAML (String iYamlFile){
    //base on the GAV input, to get the specific version from artifactory and update the YAML
    File sourceFile = new File (iYamlFile);
    String srcFilePath = sourceFile.getCanonicalPath()
    String sourceContent = sourceFile.getText("UTF-8")
    Yaml yaml = new Yaml();
    Object data = yaml.load(sourceContent);
    logger.info("GradleUtils: ${iYamlFile}")
    srcFilePath = srcFilePath.replaceAll("\\\\", "\\\\\\\\");

    data."wfoComponents".each { wfoComponents ->
        //logger.quiet(wfoComponents)
        Map<Object> wfoComponentsMap = (Map<Object>) wfoComponents
        String sComponentName =""
        String sComponentGAV = ""
        String sComponentRepo = ""
        String sCurrentVersion = ""

        wfoComponentsMap.each { wfoComponent ->
            wfoComponent.each { it ->
                logger.debug("${it}")
                String [] prop =    "${it}".split("=")
                if (prop[0]=="ComponentName") {
                    sComponentName = prop[1]
                }
                if (prop[0]=="ComponentGAV") {
                    sComponentGAV = prop[1]
                }
                if (prop[0]=="ComponentRepo") {
                    sComponentRepo = prop[1]
                }
            }
        }

        if (sComponentRepo=="") sComponentRepo="${defaultRepoKey}"

        sCurrentVersion = "${currentVersion}"

        logger.info("GradleUtils: fillSpecificVersionYAML:  ${sComponentName}:${sComponentGAV}:${sComponentRepo}:${srcFilePath}")
        if ((sComponentGAV != "") && !(sComponentGAV.contains("MasterBuildVersion") ))
            updateRequestedVersion (sComponentGAV,sComponentRepo,srcFilePath,sCurrentVersion )

    }

    // Print out the source contnet

    File yamlFile = new File (iYamlFile);

    logger.quiet(" GradleUtils: YAML file ${iYamlFile} after filling versions:\n" + yamlFile.text)

}

def updateRequestedVersion (String sComponentGAV, String sComponentRepo, String sYamlFiles, String sCurrentVersion){

    String cmdLine = "gradlew.bat --parallel -b versionRequest/build.gradle updateRequestVersion -PyamlFiles=${sYamlFiles} -PaGAV=${sComponentGAV} -PaRepoKey=${sComponentRepo} -PcurrentVersion=${sCurrentVersion}"
    // --daemon didn't help much
    // String cmdLine = "gradlew.bat --daemon --parallel -b versionRequest/build.gradle updateRequestVersion -PyamlFiles=${sYamlFiles} -PaGAV=${sComponentGAV} -PaRepoKey=${sComponentRepo}"
    executeCommandLine(cmdLine)
}


def loadJsonObject(File jsonFile) {
    String sourceContent = jsonFile.getText("UTF-8")
    def InputJSON = new JsonSlurper().parseText(sourceContent)

    return InputJSON
}

def loadXMLObject(File xmlFile) {

    def rtnXML = null

    //logger.quiet (xmlFile.text)
    try {
        //rtnXML = new XmlSlurper().parseText(xmlFile.text)
        rtnXML = new XmlParser().parseText(xmlFile.text)
    }catch (Exception e){
        logger.quiet("\nGradleUtils: XML doesn't exist or wrong format :" + xmlFile.getAbsolutePath())
        logger.quiet("${e}")
        rtnXML = null
    }
    return rtnXML
}


def getRtnCode (String strException) {
    int lastIndex =   strException.lastIndexOf("exit value")
    String strReturn=""
    if (lastIndex>0) {
        strReturn =   strException.substring(lastIndex+ "exit value".length()+1)
        //logger.quiet ("GradleUtils: strReturn=->${strReturn}<-")
    }
    return strReturn;
}

def executeCommandLine (String cmdLine) {

    String rtnCode=""
    try {
        logger.debug ("GAC: EXECUTING...:" + cmdLine )
        exec {
            commandLine 'cmd', '/c', cmdLine
        }
    }
    catch (Exception e) {
        //logger.error ("GAC: some " + e.toString())
        throw new GradleException("GradleUtils: \n " + e.toString())
    }
}

def executeOnCMDFile(String command) {
    File temp = File.createTempFile("cish",".bat");
    temp.write(command)
    //println "             *************Temp command: ******:" + temp.getAbsolutePath()

    String filePath = temp.getAbsolutePath()
    //filePath = filePath.replaceAll("\\\\","/")
    println "             *************Temp command: ******:" + filePath

    executeOnCMD filePath
    //TODO: uncomment code bellow
    //temp.delete()
}


def executeOnCMD(String command) {
    return executeOnCMD(command, new File(System.properties.'java.io.tmpdir'))
}

def executeOnCMD (String command, File workingDir) {
    println "---CommandToExecute:" + command
    def process = new ProcessBuilder(command)
            .directory(workingDir)
            .redirectErrorStream(true)
            .start()
    process.inputStream.eachLine {println it}
    //With the paexec , no need to waitFor
    //process.waitFor();
    //return process.exitValue()
}

def executeOnShellFile(String command) {
    File temp = File.createTempFile("cish",".sh");
    temp.write(command)
    //println "             *************Temp command: ******:" + temp.getAbsolutePath()

    String filePath = temp.getAbsolutePath()
    //filePath = filePath.replaceAll("\\\\","/")
    println "             *************Temp command: ******:" + filePath

    executeOnShell filePath
    //TODO: uncomment code bellow
    //temp.delete()
}

def executeOnShell(String command) {
    return executeOnShell(command, new File(System.properties.'java.io.tmpdir'))
}

def executeOnShell(String command, File workingDir) {
    println "---CommandToExecute:" + command
    def process = new ProcessBuilder(addShellPrefix(command))
            .directory(workingDir)
            .redirectErrorStream(true)
            .start()
    process.inputStream.eachLine {println it}
    process.waitFor();
    return process.exitValue()
}

def addShellPrefix(String command) {
    def commandArray = new String[3]
    commandArray[0] = "sh"
    commandArray[1] = "-c"
    commandArray[2] = command
    return commandArray
}

//Execute directly

def executeAsIs(String command) {
    println "---CommandAsIsToExecute:" + command
    def process = "$command".execute()
    process.text.eachLine {println it}
    process.waitFor();
    return process.exitValue()
}

def boolean containsPrefixes(String srcString, String prefixes) {
    def prefixesList= prefixes.split("##")
    //println ("    -------Check if : " + srcString + " has the :" + prefixes)
    boolean hasIt=false
    for (int i=0; i< prefixesList.length; i++) {
        String strTest=prefixesList[i]
        //println (" -------strTest: " + strTest)
        if (srcString.contains(strTest)) {
            hasIt = true
            break
        }
    }

    return hasIt
}

def waitAppReady (String vmIP_NA) {
    def vmIP="127.0.0.1"
    logger.quiet ("-----Start wait login page-----")
    logger.quiet ("Try load login page: http://${vmIP}/wfo/control/signin")
    //waits up to 10 minutes (and checks every 500 milliseconds) for a web server on vmIP to serve up the specified URL.
    ant.waitfor (maxwait:"10", maxwaitunit:"minute", checkevery:"500", timeoutproperty:"web.timeout") {
        http (url:"http://${vmIP}/wfo/control/signin")
    }
    ant.fail (message:"Can't display the WFO Login page, time out!", if:"web.timeout")
    logger.quiet("-----Login: READY-----")
}


def waitArtifactReady (String aURL) {
    logger.quiet ("-----Waiting for aURL available ${aURL} : -----")
    boolean rtnSuccess = true
    //waits up to 10 minutes (and checks every 500 milliseconds) for a web server on vmIP to serve up the specified URL.
    ant.waitfor (maxwait:"100", maxwaitunit:"minute", checkevery:"10000", timeoutproperty:"web.timeout") {
        http (url:"${aURL}")
    }
    try {
        ant.fail (message:"Can't find", if:"web.timeout")
    }catch (Exception e){
        rtnSuccess = false
    }

    return    rtnSuccess
}

def waitImpact360DirInfoReady(String sFileName ){

    logger.quiet ("-----Waiting for sFileName available ${sFileName} : -----")
    boolean rtnSuccess = true
    //waits up to 10 minutes (and checks every 500 milliseconds) for a web server on vmIP to serve up the specified URL.
    ant.waitfor (maxwait:"10", maxwaitunit:"minute", checkevery:"10000", timeoutproperty:"file.timeout") {
        available (file:"${sFileName}")
    }
    try {
        ant.fail (message:"Can't find", if:"file.timeout")
    }catch (Exception e){
        rtnSuccess = false
    }

    return    rtnSuccess
}

def yamlValidation(String [] yamlFiles){
    yamlFiles.each { yamlFile ->
        def yaml = new Yaml()
        def doc = new File(yamlFile).text
        try {
            def map = (Map) yaml.load(doc)
            logger.quiet ("GradleUtils: YAML (${yamlFile}) PASSED validation")
        }catch (Exception e){
            logger.quiet ("GradleUtils: Invalid YAML (${yamlFile})")
            throw new GradleException("GradleUtils:  (${e})")
        }
    }
}


task wrapper(type: Wrapper) {
    gradleVersion = supportedGradleVersion
}


def noticeLog(String strNotice){

    logger.quiet ("\n***********************************************************************************************************************************\n" +
            "****                 ${strNotice}                     ***\n" +
            "***********************************************************************************************************************************\n")

}

def noticeLog(String strNotice, File fLog){

    fLog.text = fLog.text + "\n***********************************************************************************************************************************\n" +
            "****                 ${strNotice}                     ***\n" +
            "***********************************************************************************************************************************\n"

}
//reference
//  New approach - to copy the gradleUtils to the remote and run it from there

task copyFilesPrepare << {

    // Copy the yamls translation to the workspace
    logger.info ("${yamlFiles}") ;

    def String[] yamlFilesArr = "${yamlFiles}".split(',');
    for (String yamlSrcPath : yamlFilesArr) {
        File fileToCopy = new File (yamlSrcPath)
        String fileName = fileToCopy.getName();
        ant.copy (file: "${yamlSrcPath}", tofile: "${projectDir}\\ci\\${fileName}", verbose: true)
    }

    // First to make sure
    WaitAndCreateDirRemote ("\\\\${vmIP}\\C\$\\GradleUtils")

    // Then copy

    ant.copy (todir: "\\\\${vmIP}\\C\$\\GradleUtils",overwrite:true, verbose: true){
        fileset (dir: "${projectDir}" ){
            exclude name: "**/.gradle/**"
            exclude name: "**/.git/**"
            exclude name: "**/PAExec/**"
            exclude name: "**/Pstools/**"
            exclude name: "**/build/**"
            exclude name: "**/PPLogs/**"
            exclude name: "**/dependencies_*.info"
            exclude name: "**/*.zip"
        }
    }
}

task runLocalDeployController(dependsOn: 'init') << {

    noticeLog("GradleUtils: The full flow as below\n"         )

    if ("${fillVersionRange}".toBoolean()) {
        noticeLog ("GradleUtils: Stage 1.1: Check the YAML file and fill the version as needed [SLAVE]: ${yamlFiles}")
        fillSpecificVersionYAMLs "$yamlFiles"
    }

    String pp_timestamp= Calendar.getInstance().getTimeInMillis();
    // Replace the yaml content with the new build number and create the yaml file
    String certname="${environment}_${pp_timestamp}"
    noticeLog ("GradleUtils: Stage 1.2: Generate the puppet certificate [SLAVE]")
    logger.quiet ("GradleUtils: certname:${certname}")

    def String[] yamlFiles = "${yamlFiles}".split(',');
    yamlValidation (yamlFiles)

    int yamlIndex = 0;
    String yamlSuffix = "";

    for (String yamlSrcPath : yamlFiles){
        logger.quiet ("GradleUtils: run the setting for Yaml = ${yamlSrcPath}")

        createYAML ("${currentVersion}", "${yamlSrcPath}", "${yamlDestPath}\\${certname}${yamlSuffix}.yaml")

        yamlIndex ++;
        yamlSuffix = "_${yamlIndex}"
    }

    //TODO: GEnerating the gradle file

    generateGradleRemote(certname)

    //TODO: Copy all neccessary to remote
    tasks.copyFilesPrepare.execute();

    //TODO: Run the gradle remotely

    runDeployFromTestBench("$vmIP","$vmUser","$vmPw")

    String sFileName="\\\\${vmIP}\\C\$\\GradleUtils\\${envJsonFileName}"

    String envDataPath ="\\\\${vmIP}\\C\$\\GradleUtils\\${envDataFileName}"
    String envSoftPath ="\\\\${vmIP}\\C\$\\GradleUtils\\${envSoftFileName}"

    waitImpact360DirInfoReady(envDataPath)
    waitImpact360DirInfoReady(envSoftPath)

    String strImpact360DataDir= new File(envDataPath).text
    String strImpact360SoftDir= new File(envSoftPath).text

    strImpact360DataDir =strImpact360DataDir.replaceAll("\\\\", "\\\\\\\\");
    strImpact360SoftDir =strImpact360SoftDir.replaceAll("\\\\", "\\\\\\\\");

    logger.info ("Impact360Dir got from client: strImpact360DataDir=${strImpact360DataDir} , strImpact360SoftDir=${strImpact360SoftDir} ")

    yamlIndex = 0;
    yamlSuffix = "";

    for (String yamlSrcPath : yamlFiles){
        logger.quiet ("GradleUtils: Update  = ${yamlSrcPath}")
        updateEnvParamInYaml( "${yamlDestPath}\\${certname}${yamlSuffix}.yaml", strImpact360DataDir, strImpact360SoftDir)
        yamlIndex ++;
        yamlSuffix = "_${yamlIndex}"
    }





    //WAIT for the result

//    if ("${chkApp}".toBoolean())
//        waitAppReady "$vmIP"

    noticeLog ("GradleUtils: Stage 5.2 - Waiting for the completion of remote execution then extract and fill the installed version to : PPLogs\\installedVersions.json")

    if (loadPuppetLog( "$certname","$environment")){
        String errRtnErrorCode = printRemoteLog ("$certname")
        handlePuppetErrCode errRtnErrorCode
        extractInstalledVersion(yamlFiles, new File("${projectDir}\\PPLogs\\registryExport.json"))

    }else{
        throw new GradleException ("Job runs too long. For some reasons, there is no log, couldn't know status execution remotely. Build failed")
    }

    //Now publish the error
    //handlePuppetErrCode errRtnErrorCode    
    noticeLog ("GradleUtils: DONE!!!")
}


task runLocalDeploy() << {

    File fLogStatus = new File ("${projectDir}\\${icertname}_runLocal.log")
    fLogStatus.text ="*******************DEPLLOY GRADLE LOG **********\n"

    noticeLog("GradleUtils: Creating envJson\n"         ,fLogStatus)

    String envDataPath = "${projectDir}\\${envDataFileName}"
    String envSoftPath = "${projectDir}\\${envSoftFileName}"

    createEnvJsonFiles(envDataPath,envSoftPath)


    noticeLog("GradleUtils: Execution in the Testbench\n"         ,fLogStatus)

    noticeLog ("GradleUtils: Stage 1.2: Stop the services ${stopStartservices} on ",fLogStatus)
    logger.quiet ("GradleUtils: Stop Watchdog service")
//	remoteService( vmIP, vmUser, vmPw, watchdogService , "stop")
    MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "stop")
    logger.quiet ("GradleUtils: run the puppet agent")



    // Replace the yaml content with the new build number and create the yaml file
    String certname="${icertname}"

    logger.quiet ("GradleUtils: certname:${certname}")

    String strSSLPath="C:\\ProgramData\\PuppetLabs\\puppet\\etc\\ssl"
    noticeLog ("GradleUtils: Stage Pre-2.1: Make sure the ssl folder is gone ",fLogStatus)
    logger.quiet ("GradleUtils: Make sure the ssl folder is gone:${strSSLPath}")
    File sslDir = new File("${strSSLPath}")

    if (sslDir.exists()) {
        logger.quiet ("GradleUtils: Exist...Deleting...:${strSSLPath}")
        sslDir.deleteDir()
    }

    noticeLog ("GradleUtils: Stage 2.1: Run puppet to prepare the environements ",fLogStatus)
    logger.quiet ("GradleUtils: run the initial set up on base environment with certname:${certname}")

    def String[] yamlFiles = "${yamlFiles}".split(',');


    String errRtnErrorCode=""
    errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "$certname","$environment_base","$vmIP","$vmUser","$vmPw")

    logger.quiet ("GradleUtils: ErrorCode - Base - ${errRtnErrorCode}")
    noticeLog ("GradleUtils: Stage 3.1: Run puppet to setup (uninstall, install or do both) the msi(s)\n" +
            "\t\tfor each defined yaml",fLogStatus)

    int yamlIndex = 0;
    String yamlSuffix = "";

    for (String yamlSrcPath : yamlFiles){
        if ((errRtnErrorCode=="2") ||(errRtnErrorCode=="")) {
            logger.quiet ("GradleUtils: run the setting for Yaml = ${yamlSrcPath}")
            logger.quiet ("GradleUtils: Update the Yaml file at ${yamlDestPath}\\${certname}${yamlSuffix}.yaml")

            errRtnErrorCode=runPuppetAgentCommand("$puppetServer", "${certname}${yamlSuffix}","$environment","$vmIP","$vmUser","$vmPw")
            logger.quiet ("GradleUtils: ErrorCode - ${yamlSrcPath} - ${errRtnErrorCode}")
            yamlIndex ++;
            yamlSuffix = "_${yamlIndex}"
        }
    }

    noticeLog ("GradleUtils: Stage 4: If the Stage 3 is success, else go to stage 5",fLogStatus)
    if ((errRtnErrorCode!="2") &&(errRtnErrorCode!="")) {
        logger.quiet("\nGradleUtils: ****************************************************************************")
        logger.quiet("GradleUtils: *                      ERROR ERROR IN PUPPET STEPS - COLLECTING LOGS         *")
        logger.quiet("\nGradleUtils: ****************************************************************************")
    }else{
        try {
            //Move to this to have the puppet log capture
            if ("${deployEarFile}".toBoolean()){

                noticeLog ("GradleUtils: Stage 4.1 - Run deploy the ear (if there is the need) with cscripts ",fLogStatus)

                runDeployEar (vmIP, vmUser,  vmPw)

                noticeLog ("GradleUtils: Stage 4.2 - Start the ${wfoService} services ",fLogStatus)

                remoteService (vmIP, vmUser,  vmPw, wfoService, "start")
            }

            noticeLog ("GradleUtils: Stage 4.2 - Start the services ${stopStartservices} on ",fLogStatus)
            //remoteService( vmIP, vmUser, vmPw, watchdogService , "start")
            MultiRemoteService( vmIP, vmUser, vmPw, "${stopStartservices}" , "start")

            /* [Chau] temporarily commented out
            //wait for the application ready
            noticeLog ("GradleUtils: Stage 4.3 - Check and wait until the login page come up ",fLogStatus)
            if ("${chkApp}".toBoolean())
                waitAppReady "$vmIP"
            */
        } catch (Exception e) {
            logger.quiet ("GradleUtils: some " + e.toString())
            errRtnErrorCode = getRtnCode(e.toString())
            if ((errRtnErrorCode!="2") &&(errRtnErrorCode!="")){
            }else{
                errRtnErrorCode="99"
            }
        }
    }
    //Run by the very end for gradle tasks:
    // - publish logs

    noticeLog ("GradleUtils: Stage 5.1 - Collecting the logs",fLogStatus)

    fLogStatus.text ="${errRtnErrorCode}\n" + fLogStatus.text

//    ant.copy (file: "${projectDir}\\${icertname}_runLocal.log", tofile: "C:\\Impact360\\WFOPuppet\\logs\\${icertname}_runLocal.log", verbose: true)
//    ant.copy (file: "${projectDir}\\gradlelogDeploy.log", tofile: "C:\\Impact360\\WFOPuppet\\logs\\gradlelogDeploy.log", verbose: true)
//
//    //Check the buildear.log
//    File fBuildear = new File ("C:\\Impact360\\Software\\ProductionServer\\weblogic\\Impact360\\buildear.log")
//    if (fBuildear.exists()){
//        ant.copy (file: "C:\\Impact360\\Software\\ProductionServer\\weblogic\\Impact360\\buildear.log", tofile: "C:\\Impact360\\WFOPuppet\\logs\\buildear.log", verbose: true)
//    }

    //runLogCollectionLocal( "$certname","$environment")

    //tasks.artifactoryPublish.execute();

    noticeLog ("GradleUtils: DONE!!!",fLogStatus)


}

def runLogCollectionLocal (String strCertName, String strEnv){
    //C:\Impact360\WFOPuppet\install\gradle\gradlew.bat runG aP -Pcertname=ci_wfo_env_1459267658362 -Penvironment=ci_wfo_env > C:\Impact360\WFOPuppet\logs\gradlelog.log

    String sCmd
    sCmd = "${srcRootDir}\\WFOPuppet\\install\\gradle\\gradlew.bat runG aP -Pcertname=${strCertName} -Penvironment=${strEnv}"

    String rtnCode = runRemote ("runLogCollectionLocal",sCmd, "$vmIP","$vmUser","$vmPw")

    if (rtnCode !="2"){
        logger.quiet ("Perform another attemp to get the logs")
        rtnCode = runRemote ("runLogCollectionLocal",sCmd, "$vmIP","$vmUser","$vmPw")
    }

    logger.quiet ("runLogCollection: exitCode (${rtnCode})")

}

def generateGradleRemote(String strCertName){
    //gradlew.bat -i --refresh-dependencies runPA -PcurrentVersion=15.1.0.10049 -PMasterBuildVersion=15.1.0.10049 -PvmIP=10.156.16.202 -PyamlFiles=puppet.yaml -PdeployEarFile=true -PchkApp=true -PwfoService=WFO_ProductionDomain_ProductionServer "-PstopStartservices=WatchDog,MinerTomcat,RecorderTomcat,Recorder Alarm Service" -PfillVersionRange=false

    String sCmd = "@echo off \n"+ 
            "if not exist ${srcRootDir} mkdir ${srcRootDir} \n" +
            "cd /D C:\\GradleUtils\n" +
            " \n"+ 
            "FOR /L %%G IN (1,1,10) DO ( \n"+ 
            "    echo %%G \n"+ 
            "    ping -n 60 127.0.0.1 >nul \n"+ 
            "    ping atlartifactory.lab.local | Find \"Reply\" >nul \n"+ 
            "    if not errorlevel 1 ( \n"+ 
            "        echo Successfully pinged to Artifactory. \n"+ 
            "        goto :good \n"+ 
            "    ) else ( \n"+ 
            "        echo Cannot ping Artifactory. \n"+ 
            "    ) \n"+ 
            ") \n"+ 
            ":bad \n"+ 
            "echo BAD! \n"+ 
            "EXIT /B 100 \n"+ 
            " \n"+ 
            ":good \n"+ 
            "echo GOOD! \n"+ 
            " \n"+ 
            "cmd /c gradlew.bat -i runLocalDeploy aP -PcurrentVersion=${currentVersion} -PMasterBuildVersion=${MasterBuildVersion} -PvmIP=${vmIP} -PyamlFiles=${yamlFiles} -PdeployEarFile=${deployEarFile} -PchkApp=${chkApp} -PwfoService=${wfoService} \"-PstopStartservices=${stopStartservices}\" -PfillVersionRange=false -PremoteCmd=localfile -Picertname=${strCertName} 1> C:\\GradleUtils\\gradlelogDeploy.log 2>&1"

    File cmdFile = new File ("${projectDir}\\runGradleLocalDeploy.bat")
    noticeLog ("GradleUtils: GRadle command to be run:\n ${sCmd}")
    cmdFile.text = sCmd

}


def runDeployFromTestBench (String iVmIP, String iUser, String iPw) {
    String sCmd
    // CommandLine to execute in the agent
    sCmd = "C:\\GradleUtils\\runGradleLocalDeploy.bat"

    //String rtnCode = runRemoteNonIteractive(sCmd, iVmIP,iUser,iPw)
    String rtnCode = runRemoteNonIteractive(sCmd, iVmIP,iUser,iPw)

    logger.quiet ("Run the gradle local: exitCode (${rtnCode})")

    if (rtnCode!="" && rtnCode!="0" && Integer.parseInt("${rtnCode}")<10 ) {
        logger.quiet ("GradleUtils: Failed with: exitCode (${rtnCode})")
        throw new GradleException("GradleUtils: Failed to gradle in test bench exitCode (${rtnCode})")
    }
}

def String printRemoteLog(String certname){
    String strRtn = ""
    File fLog = new File("${projectDir}\\PPLogs\\${certname}_runLocal.log")
    noticeLog(fLog.text)

    new File("${projectDir}\\PPLogs\\${certname}_runLocal.log").withReader{
        strRtn = it.readLine();
    }

}


///***         MOVING THE LOG HANDLE HERE FROM PUPPET CLINET GRADLE


import com.github.sarxos.winreg.HKey;
import com.github.sarxos.winreg.RegistryException;
import com.github.sarxos.winreg.WindowsRegistry;
// List of function that we can use

def readRegistries( ){
    String strDataDir=System.getenv("IMPACT360DATADIR")
    String strSoftwareDir=System.getenv("IMPACT360SOFTWAREDIR")
    if (!strDataDir) strDataDir="${impact360DataDir}"
    if (!strSoftwareDir) strSoftwareDir = "${impact360SoftwareDir}"

    def parsedXmlObj =loadXML ("${strSoftwareDir}\\${srcLogInstallXML}")
    WindowsRegistry reg = WindowsRegistry.getInstance();
    //String tree = "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
    //String value = reg.readString(HKey.HKLM, tree, "ProductName");
    String branch = "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
    String branch64 = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
    List<String> allKeys = new ArrayList<String>();		// list for all keys (32 and 64)
    List<String> keys = reg.readStringSubKeys(HKey.HKLM, branch);
    List<String> keys64 = reg.readStringSubKeys(HKey.HKLM, branch64); // adding key for 64
    allKeys.addAll(keys);		// adding 32 keys
    allKeys.addAll(keys64);		// adding 64
    def registryDiffFile = new File ("$srcLogDir\\ServerVersionInstalledMismatch.log")
    registryDiffFile.write "List of mismatch of registry and ServerVersionInformation.xml\n"

    def registryLogFile = new File ("$srcLogDir\\Registry.log")
    registryLogFile.write "### ALL REGISTRY ENTRIES ###\n"

    def fullRegistryFile = new File ("$srcLogDir\\registryExport.json")
    String fullRegistryContent = ""
    String jsonItemHeader=""

    String valueDisplayName = "";
    String valueDisplayVersion = "";
    String valuePublisher = "";

    for (String key : keys) {
        logger.quiet("GradleUtils Test: looking for key: ${key} in Wow6432Node");
        valueDisplayName = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayName");
        valueDisplayVersion = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayVersion");
        valuePublisher = reg.readString(HKey.HKLM,  "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "Publisher");
        logger.quiet("GradleUtils Test: key: ${key} AND valueDisplayName: ${valueDisplayName}");

        registryLogFile << "${key} :: ${valueDisplayName} :: ${valueDisplayVersion} :: ${valuePublisher}\n"
        if (fullRegistryContent=="") {
            fullRegistryContent ="  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }else{
            fullRegistryContent =fullRegistryContent +",\n  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }

        // log mismatch components
        def component = getXMLComponent(parsedXmlObj,key)
        if (component !=null){
            if ((component.@name != valueDisplayName) || (component.@version != valueDisplayVersion)){
                registryDiffFile << "Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})\n"
                logger.quiet("Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})")
            }
        }else {
            if (valuePublisher!=null && valuePublisher.contains("Impact")){
                registryDiffFile << "**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}\n"
                logger.quiet("**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}")
            }
        }
    }


    //[Chau] Debug
    keys64.add("{4357B77A-3432-483f-B95C-B6A218EA9583}")
    keys64.add("{19124C4F-FFB2-4031-B52D-1A0FB703D56D}")


    for (String key : keys64) {

        logger.quiet("GradleUtils Test: looking for key: ${key} for 64bit");
        //static Pattern escaper = Pattern.compile("([^a-zA-z0-9])");
        //key =  key.replaceAll( /([^a-zA-Z0-9])/, '\\\\$1' )
        //key = key.replaceAll('$' , '\$');
        logger.quiet("GradleUtils Test: key after replacement : ${key}");
        valueDisplayName = reg.readString(HKey.HKLM,  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayName");
        valueDisplayVersion = reg.readString(HKey.HKLM,  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "DisplayVersion");
        valuePublisher = reg.readString(HKey.HKLM,  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${key}", "Publisher");
        logger.quiet("GradleUtils Test: key: ${key} AND valueDisplayName: ${valueDisplayName}");

        registryLogFile << "${key} :: ${valueDisplayName} :: ${valueDisplayVersion} :: ${valuePublisher}\n"
        if (fullRegistryContent=="") {
            fullRegistryContent ="  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }else{
            fullRegistryContent =fullRegistryContent +",\n  \"${key}\": {\n" +
                    "    \"ComponentName\": \"${valueDisplayName}\",\n" +
                    "    \"InstalledVersion\": \"${valueDisplayVersion}\",\n" +
                    "    \"Key\": \"${key}\",\n" +
                    "    \"Publisher\": \"${valuePublisher}\"\n" +
                    "  }"
        }

        // log mismatch components
        def component = getXMLComponent(parsedXmlObj,key)
        if (component !=null){
            if ((component.@name != valueDisplayName) || (component.@version != valueDisplayVersion)){
                registryDiffFile << "Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})\n"
                logger.quiet("Component id=${key} ServerVeversion (${component.@name}, ${component.@version}) != Registry (${valueDisplayName},${valueDisplayVersion})")
            }
        }else {
            if (valuePublisher!=null && valuePublisher.contains("Impact")){
                registryDiffFile << "**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}\n"
                logger.quiet("**************Not exist id=${key} Registry (${valueDisplayName},${valueDisplayVersion}) Publisher: ${valuePublisher}")
            }
        }

    }

    fullRegistryFile.write "{\n${fullRegistryContent}\n}"

}

def loadXML(String xmlSrcPath){
    def parsedXml = (new XmlParser()).parse(xmlSrcPath)
    return parsedXml
}

def getXMLComponent(Object parsedXML, String id){
    def rtnObj = null
    def foundIt = false
    parsedXML.Components.Component.each { component ->
        if (!foundIt &&(component.@id=="${id}") ) {
            rtnObj=component
            foundIt =true
        }
    }
    return rtnObj
}


task zipLogs() <<{
    String srcDir = "$srcLogDir"
    String strDataDir=System.getenv("IMPACT360DATADIR")
    String strSoftwareDir=System.getenv("IMPACT360SOFTWAREDIR")
    if (!strDataDir) strDataDir="${impact360DataDir}"
    if (!strSoftwareDir) strSoftwareDir = "${impact360SoftwareDir}"

    logger.quiet("Zipping the log from: ${srcDir} from puppet client")

    ant.copy (todir:"${srcDir}", file:"${strSoftwareDir}\\${srcLogInstallXML}", failonerror: false)
    //Copy the production logs
    copyProductionLogs "${strDataDir}","${srcDir}\\productionLogs"

    ant.copy (file: "${projectDir}\\${icertname}_runLocal.log", tofile: "${srcLogDir}\\${icertname}_runLocal.log", verbose: true)
    ant.copy (file: "${projectDir}\\gradlelogDeploy.log", tofile: "${srcLogDir}\\gradlelogDeploy.log", verbose: true)

    //Check the buildear.log
    File fBuildear = new File ("${strSoftwareDir}\\ProductionServer\\weblogic\\Impact360\\buildear.log")
    if (fBuildear.exists()){
        ant.copy (file: "${strSoftwareDir}\\ProductionServer\\weblogic\\Impact360\\buildear.log", tofile: "${srcLogDir}\\buildear.log", verbose: true, failonerror: false)
    }
    //logger.quiet ("GradlePuppetClient: getting the installed versions from the certname ${certname}")
    logger.quiet ("Zipping: gett and export the registry ")
    readRegistries()

    ant.zip(destfile: "$buildDir/pplog.zip") {
        fileset(dir: "${srcDir}") {
            //include(name: '**.xml')
            exclude(name: ".gradle\\**\\*")
            exclude(name: "build\\**\\*")
            exclude(name: "**\\*.zip")
        }

    }
}

def copyProductionLogs (String srcDir, String dstDir){
    // srcDir: C:\\Impact360\\Data
    ant.copy (todir: "${dstDir}" ){
        fileset(dir: "${srcDir}") {
            include(name: "Logs\\**\\*.log")
        }
    }
}


def updateEnvParamInYaml(String strPath, String strImpact360DataDir, String strImpact360SoftDir){
    File fYaml = new File ("${strPath}")
    String sourceContent = fYaml.text

    String strDataDir=strImpact360DataDir
    String strSoftwareDir=strImpact360SoftDir

    String pp_artifactory_username  = "${artifactory_user}"
    String pp_artifactory_password  = "${artifactory_password}"

    if (strDataDir=="" || !strDataDir) strDataDir="${impact360DataDir}"
    if (strSoftwareDir=="" || !strSoftwareDir) strSoftwareDir = "${impact360SoftwareDir}"

    String strToBeReplaceWith = "---\ndata_dir   : '${strDataDir}'\n" +
            "artifactory_username   : '${pp_artifactory_username}'\n" +
            "artifactory_password   : '${pp_artifactory_password}'\n" +
            "software_dir   : '${strSoftwareDir}'\n\n"
    if(sourceContent.contains("---")){
        sourceContent=sourceContent.replaceAll("---",strToBeReplaceWith)
    }
    else{
        sourceContent = strToBeReplaceWith + sourceContent
    }

    fYaml.text = sourceContent

    logger.quiet("Final Yaml:")
    logger.quiet(fYaml.text)

}

def createEnvJsonFile(String strPath){

    String strDataDir=System.getenv("IMPACT360DATADIR")
    String strSoftwareDir=System.getenv("IMPACT360SOFTWAREDIR")

    String strContent = "{\n" +
            "  \"IMPACT360SOFTWAREDIR\": \"${strSoftwareDir}\",\n" +
            "  \"IMPACT360DATADIR\": \"${strDataDir}\"\n" +
            "  \n" +
            "}"
    File fJson = new File(strPath)
    fJson.write(strContent,'UTF-8')
    logger.quiet(fJson.text)
}

def createEnvJsonFiles(String strDataPath, String strSoftPath){

    String strDataDir=System.getenv("IMPACT360DATADIR")
    String strSoftwareDir=System.getenv("IMPACT360SOFTWAREDIR")

    File fData = new File(strDataPath)
    fData.text = strDataDir

    File fSoft = new File(strSoftPath)
    fSoft.text = strSoftwareDir

}



def renameEnvJsonFile (String envJsonPathTemp, String  envJsonPath){
    ant.copy (file: "${envJsonPathTemp}", tofile: "${envJsonPath}", verbose: true)
}

def WaitAndCreateDirRemote(String strDir){

    boolean bCreateSuccessful = false
    def rtnException
    for (int i=0; i<10 && !bCreateSuccessful; i++){
        def boolean bValue = true
        try {

            println ("running :\"net use \\\\${vmIP}\\C\$ /user:${vmUser} ${vmPw}\"")
            // Now copy everything to remoret
            ant.exec(executable: "cmd", failonerror:"false") {
                arg line: '/c'
                arg line: "net use \\\\${vmIP}\\C\$ /user:${vmUser} ${vmPw}"
            }

            ant.mkdir (dir: strDir)
        }catch(Exception e){
            logger.quiet ("GradleUtils: Failed in creating ${strDir} try in 1'...${e}")
            ant.sleep (minutes: 1)
            bValue = false
            rtnException = e
        }
        bCreateSuccessful = bValue
    }

    if (!bCreateSuccessful) throw new GradleException("GradleUtils: Failed to create the dir: ${strDir} with Exception: ${rtnException}")


}

artifactoryPublish.dependsOn zipLogs


artifactory {
    publish {
        contextUrl = "${artifactory_contextUrl}"	// The base Artifactory URL if not overridden by the publisher/resolver
        repository {
            repoKey = 'devops'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
    }
    resolve {
        contextUrl = "${artifactory_contextUrl}"	// The base Artifactory URL if not overridden by the publisher/resolver
        repository {
            repoKey = 'repo'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
    }
}

apply from: 'yamlBuilder.gradle'
//*************